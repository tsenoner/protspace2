<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/rostlab_circle.png" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ProtSpace</title>
    <script type="module" crossorigin src="/assets/index-iAuL48VL.js"></script>
    <link rel="stylesheet" crossorigin href="/assets/index-BhgDMsuF.css">
  </head>
  <body>
    <div id="root"></div>
    <script src="tsne.js"></script>
    <script>
      !(function (t) {
        var r = {};
        function e(n) {
          if (r[n]) return r[n].exports;
          var i = (r[n] = { i: n, l: !1, exports: {} });
          return t[n].call(i.exports, i, i.exports, e), (i.l = !0), i.exports;
        }
        (e.m = t),
          (e.c = r),
          (e.d = function (t, r, n) {
            e.o(t, r) ||
              Object.defineProperty(t, r, { enumerable: !0, get: n });
          }),
          (e.r = function (t) {
            "undefined" != typeof Symbol &&
              Symbol.toStringTag &&
              Object.defineProperty(t, Symbol.toStringTag, { value: "Module" }),
              Object.defineProperty(t, "__esModule", { value: !0 });
          }),
          (e.t = function (t, r) {
            if ((1 & r && (t = e(t)), 8 & r)) return t;
            if (4 & r && "object" == typeof t && t && t.__esModule) return t;
            var n = Object.create(null);
            if (
              (e.r(n),
              Object.defineProperty(n, "default", { enumerable: !0, value: t }),
              2 & r && "string" != typeof t)
            )
              for (var i in t)
                e.d(
                  n,
                  i,
                  function (r) {
                    return t[r];
                  }.bind(null, i)
                );
            return n;
          }),
          (e.n = function (t) {
            var r =
              t && t.__esModule
                ? function () {
                    return t.default;
                  }
                : function () {
                    return t;
                  };
            return e.d(r, "a", r), r;
          }),
          (e.o = function (t, r) {
            return Object.prototype.hasOwnProperty.call(t, r);
          }),
          (e.p = ""),
          e((e.s = 2));
      })([
        function (t, r, e) {
          "use strict";
          const n = Object.prototype.toString;
          t.exports = function (t) {
            return n.call(t).endsWith("Array]");
          };
        },
        function (t, r, e) {
          "use strict";
          var n =
            (this && this.__values) ||
            function (t) {
              var r = "function" == typeof Symbol && t[Symbol.iterator],
                e = 0;
              return r
                ? r.call(t)
                : {
                    next: function () {
                      return (
                        t && e >= t.length && (t = void 0),
                        { value: t && t[e++], done: !t }
                      );
                    },
                  };
            };
          function i(t) {
            return void 0 === t && (t = Math.random), t();
          }
          function o(t) {
            for (var r = [], e = 0; e < t; e++) r.push(void 0);
            return r;
          }
          function s(t, r) {
            return o(t).map(function () {
              return r;
            });
          }
          function a(t) {
            return t.reduce(function (t, r) {
              return t + r;
            });
          }
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r.randomNormal2d = function (t, r, e, n) {
              return (
                void 0 === t && (t = 0),
                void 0 === r && (r = 1),
                void 0 === e && (e = [1, 1]),
                void 0 === n && (n = Math.random),
                Array(e[0])
                  .fill(0)
                  .map(function () {
                    return Array(e[1])
                      .fill(0)
                      .map(function () {
                        return (function (t, r, e) {
                          void 0 === e && (e = Math.random);
                          var n = i(e),
                            o = i(e);
                          return (
                            Math.sqrt(-2 * Math.log(n)) *
                              Math.cos(2 * Math.PI * o) *
                              r +
                            t
                          );
                        })(t, r, n);
                      });
                  })
              );
            }),
            (r.tauRandInt = function (t, r) {
              return void 0 === r && (r = Math.random), Math.floor(r() * t);
            }),
            (r.tauRand = i),
            (r.norm = function (t) {
              var r,
                e,
                i = 0;
              try {
                for (var o = n(t), s = o.next(); !s.done; s = o.next()) {
                  var a = s.value;
                  i += Math.pow(a, 2);
                }
              } catch (t) {
                r = { error: t };
              } finally {
                try {
                  s && !s.done && (e = o.return) && e.call(o);
                } finally {
                  if (r) throw r.error;
                }
              }
              return Math.sqrt(i);
            }),
            (r.empty = o),
            (r.range = function (t) {
              return o(t).map(function (t, r) {
                return r;
              });
            }),
            (r.filled = s),
            (r.zeros = function (t) {
              return s(t, 0);
            }),
            (r.ones = function (t) {
              return s(t, 1);
            }),
            (r.linear = function (t, r, e) {
              return o(e).map(function (n, i) {
                return t + i * ((r - t) / (e - 1));
              });
            }),
            (r.sum = a),
            (r.mean = function (t) {
              return a(t) / t.length;
            }),
            (r.max = function (t) {
              for (var r = 0, e = 0; e < t.length; e++) r = t[e] > r ? t[e] : r;
              return r;
            }),
            (r.max2d = function (t) {
              for (var r = 0, e = 0; e < t.length; e++)
                for (var n = 0; n < t[e].length; n++)
                  r = t[e][n] > r ? t[e][n] : r;
              return r;
            });
        },
        function (t, r, e) {
          "use strict";
          Object.defineProperty(r, "__esModule", { value: !0 });
          var n = e(3);
          window.UMAP = n.UMAP;
        },
        function (t, r, e) {
          "use strict";
          var n =
              (this && this.__awaiter) ||
              function (t, r, e, n) {
                return new (e || (e = Promise))(function (i, o) {
                  function s(t) {
                    try {
                      h(n.next(t));
                    } catch (t) {
                      o(t);
                    }
                  }
                  function a(t) {
                    try {
                      h(n.throw(t));
                    } catch (t) {
                      o(t);
                    }
                  }
                  function h(t) {
                    t.done
                      ? i(t.value)
                      : new e(function (r) {
                          r(t.value);
                        }).then(s, a);
                  }
                  h((n = n.apply(t, r || [])).next());
                });
              },
            i =
              (this && this.__generator) ||
              function (t, r) {
                var e,
                  n,
                  i,
                  o,
                  s = {
                    label: 0,
                    sent: function () {
                      if (1 & i[0]) throw i[1];
                      return i[1];
                    },
                    trys: [],
                    ops: [],
                  };
                return (
                  (o = { next: a(0), throw: a(1), return: a(2) }),
                  "function" == typeof Symbol &&
                    (o[Symbol.iterator] = function () {
                      return this;
                    }),
                  o
                );
                function a(o) {
                  return function (a) {
                    return (function (o) {
                      if (e)
                        throw new TypeError("Generator is already executing.");
                      for (; s; )
                        try {
                          if (
                            ((e = 1),
                            n &&
                              (i =
                                2 & o[0]
                                  ? n.return
                                  : o[0]
                                  ? n.throw || ((i = n.return) && i.call(n), 0)
                                  : n.next) &&
                              !(i = i.call(n, o[1])).done)
                          )
                            return i;
                          switch (
                            ((n = 0), i && (o = [2 & o[0], i.value]), o[0])
                          ) {
                            case 0:
                            case 1:
                              i = o;
                              break;
                            case 4:
                              return s.label++, { value: o[1], done: !1 };
                            case 5:
                              s.label++, (n = o[1]), (o = [0]);
                              continue;
                            case 7:
                              (o = s.ops.pop()), s.trys.pop();
                              continue;
                            default:
                              if (
                                !(i =
                                  (i = s.trys).length > 0 && i[i.length - 1]) &&
                                (6 === o[0] || 2 === o[0])
                              ) {
                                s = 0;
                                continue;
                              }
                              if (
                                3 === o[0] &&
                                (!i || (o[1] > i[0] && o[1] < i[3]))
                              ) {
                                s.label = o[1];
                                break;
                              }
                              if (6 === o[0] && s.label < i[1]) {
                                (s.label = i[1]), (i = o);
                                break;
                              }
                              if (i && s.label < i[2]) {
                                (s.label = i[2]), s.ops.push(o);
                                break;
                              }
                              i[2] && s.ops.pop(), s.trys.pop();
                              continue;
                          }
                          o = r.call(t, s);
                        } catch (t) {
                          (o = [6, t]), (n = 0);
                        } finally {
                          e = i = 0;
                        }
                      if (5 & o[0]) throw o[1];
                      return { value: o[0] ? o[1] : void 0, done: !0 };
                    })([o, a]);
                  };
                }
              },
            o =
              (this && this.__read) ||
              function (t, r) {
                var e = "function" == typeof Symbol && t[Symbol.iterator];
                if (!e) return t;
                var n,
                  i,
                  o = e.call(t),
                  s = [];
                try {
                  for (; (void 0 === r || r-- > 0) && !(n = o.next()).done; )
                    s.push(n.value);
                } catch (t) {
                  i = { error: t };
                } finally {
                  try {
                    n && !n.done && (e = o.return) && e.call(o);
                  } finally {
                    if (i) throw i.error;
                  }
                }
                return s;
              },
            s =
              (this && this.__spread) ||
              function () {
                for (var t = [], r = 0; r < arguments.length; r++)
                  t = t.concat(o(arguments[r]));
                return t;
              };
          Object.defineProperty(r, "__esModule", { value: !0 });
          var a = e(4),
            h = e(5),
            u = e(7),
            l = e(1),
            f = e(8),
            c = (function () {
              function t(t) {
                void 0 === t && (t = {}),
                  (this.minDist = 0.1),
                  (this.nComponents = 2),
                  (this.nEpochs = 0),
                  (this.nNeighbors = 15),
                  (this.random = Math.random),
                  (this.spread = 1),
                  (this.targetMetric = "categorical"),
                  (this.targetWeight = 0.5),
                  (this.targetNNeighbors = this.nNeighbors),
                  (this.distanceFn = m),
                  (this.isInitialized = !1),
                  (this.embedding = []),
                  (this.optimizationState = new g()),
                  (this.minDist = t.minDist || this.minDist),
                  (this.nComponents = t.nComponents || this.nComponents),
                  (this.nEpochs = t.nEpochs || this.nEpochs),
                  (this.nNeighbors = t.nNeighbors || this.nNeighbors),
                  (this.random = t.random || this.random),
                  (this.spread = t.spread || this.spread);
              }
              return (
                (t.prototype.fit = function (t) {
                  return (
                    this.initializeFit(t), this.optimizeLayout(), this.embedding
                  );
                }),
                (t.prototype.fitAsync = function (t, r) {
                  return (
                    void 0 === r &&
                      (r = function () {
                        return !0;
                      }),
                    n(this, void 0, void 0, function () {
                      return i(this, function (e) {
                        switch (e.label) {
                          case 0:
                            return (
                              this.initializeFit(t), [4, this.optimizeLayout(r)]
                            );
                          case 1:
                            return e.sent(), [2, this.embedding];
                        }
                      });
                    })
                  );
                }),
                (t.prototype.setSupervisedProjection = function (t, r) {
                  void 0 === r && (r = {}),
                    (this.Y = t),
                    (this.targetMetric = r.targetMetric || this.targetMetric),
                    (this.targetWeight = r.targetWeight || this.targetWeight),
                    (this.targetNNeighbors =
                      r.targetNNeighbors || this.targetNNeighbors);
                }),
                (t.prototype.setPrecomputedKNN = function (t, r) {
                  (this.knnIndices = t), (this.knnDistances = r);
                }),
                (t.prototype.initializeFit = function (t) {
                  if (this.X === t && this.isInitialized)
                    return this.getNEpochs();
                  if (((this.X = t), !this.knnIndices && !this.knnDistances)) {
                    var r = this.nearestNeighbors(t);
                    (this.knnIndices = r.knnIndices),
                      (this.knnDistances = r.knnDistances);
                  }
                  (this.graph = this.fuzzySimplicialSet(t, this.nNeighbors)),
                    this.processGraphForSupervisedProjection();
                  var e = this.initializeSimplicialSetEmbedding(),
                    n = e.head,
                    i = e.tail,
                    o = e.epochsPerSample;
                  return (
                    (this.optimizationState.head = n),
                    (this.optimizationState.tail = i),
                    (this.optimizationState.epochsPerSample = o),
                    (this.isInitialized = !0),
                    this.getNEpochs()
                  );
                }),
                (t.prototype.processGraphForSupervisedProjection = function () {
                  var t = this.Y,
                    r = this.X;
                  if (t) {
                    if (t.length !== r.length)
                      throw new Error("Length of X and y must be equal");
                    if ("categorical" === this.targetMetric) {
                      var e =
                        this.targetWeight < 1
                          ? (1 / (1 - this.targetWeight)) * 2.5
                          : 1e12;
                      this.graph = this.categoricalSimplicialSetIntersection(
                        this.graph,
                        t,
                        e
                      );
                    }
                  }
                }),
                (t.prototype.step = function () {
                  var t = this.optimizationState,
                    r = t.currentEpoch;
                  return (
                    t.isInitialized || this.initializeOptimization(),
                    r < this.getNEpochs() && this.optimizeLayoutStep(r),
                    this.optimizationState.currentEpoch
                  );
                }),
                (t.prototype.getEmbedding = function () {
                  return this.embedding;
                }),
                (t.prototype.nearestNeighbors = function (t) {
                  var r,
                    e = this.distanceFn,
                    n = this.nNeighbors,
                    i = h.makeNNDescent(e, this.random),
                    o =
                      5 +
                      Math.floor(
                        0.5 === (r = Math.pow(t.length, 0.5) / 20)
                          ? 0
                          : Math.round(r)
                      ),
                    s = Math.max(
                      5,
                      Math.floor(
                        Math.round(
                          (function (t) {
                            return Math.log(t) / Math.log(2);
                          })(t.length)
                        )
                      )
                    ),
                    a = u.makeForest(t, n, o, this.random),
                    l = i(t, u.makeLeafArray(a), n, s);
                  return { knnIndices: l.indices, knnDistances: l.weights };
                }),
                (t.prototype.fuzzySimplicialSet = function (t, r, e, n) {
                  void 0 === e && (e = 1), void 0 === n && (n = 1);
                  var i = this.knnIndices,
                    o = void 0 === i ? [] : i,
                    s = this.knnDistances,
                    h = void 0 === s ? [] : s,
                    u = this.smoothKNNDistance(h, r, e),
                    l = u.sigmas,
                    f = u.rhos,
                    c = this.computeMembershipStrengths(o, h, l, f),
                    m = c.rows,
                    g = c.cols,
                    v = c.vals,
                    p = [t.length, t.length],
                    w = new a.SparseMatrix(m, g, v, p),
                    d = a.transpose(w),
                    y = a.pairwiseMultiply(w, d),
                    b = a.subtract(a.add(w, d), y),
                    M = a.multiplyScalar(b, n),
                    x = a.multiplyScalar(y, 1 - n);
                  return a.add(M, x);
                }),
                (t.prototype.categoricalSimplicialSetIntersection = function (
                  t,
                  r,
                  e,
                  n
                ) {
                  void 0 === n && (n = 1);
                  var i = d(t, r, n, e);
                  return y((i = a.eliminateZeros(i)));
                }),
                (t.prototype.smoothKNNDistance = function (t, r, e, n, i) {
                  void 0 === e && (e = 1),
                    void 0 === n && (n = 64),
                    void 0 === i && (i = 1);
                  for (
                    var o = (Math.log(r) / Math.log(2)) * i,
                      s = l.zeros(t.length),
                      a = l.zeros(t.length),
                      h = 0;
                    h < t.length;
                    h++
                  ) {
                    var u = 0,
                      f = 1 / 0,
                      c = 1,
                      m = t[h],
                      g = m.filter(function (t) {
                        return t > 0;
                      });
                    if (g.length >= e) {
                      var v = Math.floor(e),
                        p = e - v;
                      v > 0
                        ? ((s[h] = g[v - 1]),
                          p > 1e-5 && (s[h] += p * (g[v] - g[v - 1])))
                        : (s[h] = p * g[0]);
                    } else g.length > 0 && (s[h] = l.max(g));
                    for (var w = 0; w < n; w++) {
                      for (var d = 0, y = 1; y < t[h].length; y++) {
                        var b = t[h][y] - s[h];
                        d += b > 0 ? Math.exp(-b / c) : 1;
                      }
                      if (Math.abs(d - o) < 1e-5) break;
                      d > o
                        ? (c = (u + (f = c)) / 2)
                        : ((u = c), f === 1 / 0 ? (c *= 2) : (c = (u + f) / 2));
                    }
                    if (((a[h] = c), s[h] > 0)) {
                      var M = l.mean(m);
                      a[h] < 0.001 * M && (a[h] = 0.001 * M);
                    } else {
                      var x = l.mean(t.map(l.mean));
                      a[h] < 0.001 * x && (a[h] = 0.001 * x);
                    }
                  }
                  return { sigmas: a, rhos: s };
                }),
                (t.prototype.computeMembershipStrengths = function (
                  t,
                  r,
                  e,
                  n
                ) {
                  for (
                    var i = t.length,
                      o = t[0].length,
                      s = l.zeros(i * o),
                      a = l.zeros(i * o),
                      h = l.zeros(i * o),
                      u = 0;
                    u < i;
                    u++
                  )
                    for (var f = 0; f < o; f++) {
                      var c = 0;
                      -1 !== t[u][f] &&
                        ((c =
                          t[u][f] === u
                            ? 0
                            : r[u][f] - n[u] <= 0
                            ? 1
                            : Math.exp(-(r[u][f] - n[u]) / e[u])),
                        (s[u * o + f] = u),
                        (a[u * o + f] = t[u][f]),
                        (h[u * o + f] = c));
                    }
                  return { rows: s, cols: a, vals: h };
                }),
                (t.prototype.initializeSimplicialSetEmbedding = function () {
                  for (
                    var t = this,
                      r = this.getNEpochs(),
                      e = this.nComponents,
                      n = this.graph.getValues(),
                      i = 0,
                      o = 0;
                    o < n.length;
                    o++
                  ) {
                    var s = n[o];
                    i < n[o] && (i = s);
                  }
                  var a = this.graph.map(function (t) {
                    return t < i / r ? 0 : t;
                  });
                  this.embedding = l.zeros(a.nRows).map(function () {
                    return l.zeros(e).map(function () {
                      return 20 * l.tauRand(t.random) - 10;
                    });
                  });
                  var h = [],
                    u = [],
                    f = [];
                  for (o = 0; o < a.nRows; o++)
                    for (var c = 0; c < a.nCols; c++) {
                      (s = a.get(o, c)) && (h.push(s), f.push(o), u.push(c));
                    }
                  return {
                    head: u,
                    tail: f,
                    epochsPerSample: this.makeEpochsPerSample(h, r),
                  };
                }),
                (t.prototype.makeEpochsPerSample = function (t, r) {
                  var e = l.filled(t.length, -1),
                    n = l.max(t),
                    i = t.map(function (t) {
                      return (t / n) * r;
                    });
                  return (
                    i.forEach(function (t, n) {
                      t > 0 && (e[n] = r / i[n]);
                    }),
                    e
                  );
                }),
                (t.prototype.initializeOptimization = function () {
                  var t = this.embedding,
                    r = this.embedding,
                    e = this.optimizationState,
                    n = e.head,
                    i = e.tail,
                    o = e.epochsPerSample,
                    a = this.getNEpochs(),
                    h = this.graph.nCols,
                    u = w(this.spread, this.minDist),
                    l = u.a,
                    f = u.b,
                    c = t[0].length,
                    m = t.length === r.length,
                    g = o.map(function (t) {
                      return t / 5;
                    }),
                    v = s(g),
                    p = s(o);
                  Object.assign(this.optimizationState, {
                    isInitialized: !0,
                    headEmbedding: t,
                    tailEmbedding: r,
                    head: n,
                    tail: i,
                    epochsPerSample: o,
                    epochOfNextSample: p,
                    epochOfNextNegativeSample: v,
                    epochsPerNegativeSample: g,
                    moveOther: m,
                    initialAlpha: 1,
                    alpha: 1,
                    gamma: 1,
                    a: l,
                    b: f,
                    dim: c,
                    nEpochs: a,
                    nVertices: h,
                  });
                }),
                (t.prototype.optimizeLayoutStep = function (t) {
                  for (
                    var r = this.optimizationState,
                      e = r.head,
                      n = r.tail,
                      i = r.headEmbedding,
                      o = r.tailEmbedding,
                      s = r.epochsPerSample,
                      a = r.epochOfNextSample,
                      h = r.epochOfNextNegativeSample,
                      u = r.epochsPerNegativeSample,
                      f = r.moveOther,
                      c = r.initialAlpha,
                      m = r.alpha,
                      g = r.gamma,
                      w = r.a,
                      d = r.b,
                      y = r.dim,
                      b = r.nEpochs,
                      M = r.nVertices,
                      x = 0;
                    x < s.length;
                    x++
                  )
                    if (!(a[x] > t)) {
                      var S = e[x],
                        E = n[x],
                        R = i[S],
                        k = o[E],
                        A = p(R, k),
                        N = 0;
                      A > 0 &&
                        ((N = -2 * w * d * Math.pow(A, d - 1)),
                        (N /= w * Math.pow(A, d) + 1));
                      for (var V = 0; V < y; V++) {
                        var z = v(N * (R[V] - k[V]), 4);
                        (R[V] += z * m), f && (k[V] += -z * m);
                      }
                      a[x] += s[x];
                      for (
                        var C = Math.floor((t - h[x]) / u[x]), I = 0;
                        I < C;
                        I++
                      ) {
                        var j = l.tauRandInt(M, this.random),
                          P = o[j],
                          D = p(R, P),
                          _ = 0;
                        if (D > 0)
                          (_ = 2 * g * d),
                            (_ /= (0.001 + D) * (w * Math.pow(D, d) + 1));
                        else if (S === j) continue;
                        for (V = 0; V < y; V++) {
                          z = 4;
                          _ > 0 && (z = v(_ * (R[V] - P[V]), 4)),
                            (R[V] += z * m);
                        }
                      }
                      h[x] += C * u[x];
                    }
                  return (
                    (r.alpha = c * (1 - t / b)),
                    (r.currentEpoch += 1),
                    (this.embedding = i),
                    r.currentEpoch
                  );
                }),
                (t.prototype.optimizeLayout = function (t) {
                  var r = this;
                  return (
                    void 0 === t &&
                      (t = function () {
                        return !0;
                      }),
                    this.optimizationState.isInitialized ||
                      this.initializeOptimization(),
                    new Promise(function (e, o) {
                      var s = function () {
                        return n(r, void 0, void 0, function () {
                          var r, n, a, h, u, l;
                          return i(this, function (i) {
                            try {
                              if (
                                ((r = this.optimizationState),
                                (n = r.nEpochs),
                                (a = r.currentEpoch),
                                (h = this.optimizeLayoutStep(a)),
                                (u = !1 === t(h)),
                                (l = h === n),
                                u || l)
                              )
                                return [2, e(l)];
                              s();
                            } catch (t) {
                              o(t);
                            }
                            return [2];
                          });
                        });
                      };
                      s();
                    })
                  );
                }),
                (t.prototype.getNEpochs = function () {
                  var t = this.graph;
                  if (this.nEpochs > 0) return this.nEpochs;
                  var r = t.nRows;
                  return r <= 2500
                    ? 500
                    : r <= 5e3
                    ? 400
                    : r <= 7500
                    ? 300
                    : 200;
                }),
                t
              );
            })();
          function m(t, r) {
            for (var e = 0, n = 0; n < t.length; n++)
              e += Math.pow(t[n] - r[n], 2);
            return Math.sqrt(e);
          }
          (r.UMAP = c),
            (r.euclidean = m),
            (r.cosine = function (t, r) {
              for (var e = 0, n = 0, i = 0, o = 0; o < t.length; o++)
                (e += t[o] * r[o]),
                  (n += Math.pow(t[o], 2)),
                  (i += Math.pow(r[o], 2));
              return 0 === n && 0 === i
                ? 0
                : 0 === n || 0 === i
                ? 1
                : 1 - e / Math.sqrt(n * i);
            });
          var g = (function () {
            return function () {
              (this.currentEpoch = 0),
                (this.isInitialized = !1),
                (this.headEmbedding = []),
                (this.tailEmbedding = []),
                (this.head = []),
                (this.tail = []),
                (this.epochsPerSample = []),
                (this.epochOfNextSample = []),
                (this.epochOfNextNegativeSample = []),
                (this.epochsPerNegativeSample = []),
                (this.moveOther = !0),
                (this.initialAlpha = 1),
                (this.alpha = 1),
                (this.gamma = 1),
                (this.a = 1.5769434603113077),
                (this.b = 0.8950608779109733),
                (this.dim = 2),
                (this.nEpochs = 500),
                (this.nVertices = 0);
            };
          })();
          function v(t, r) {
            return t > r ? r : t < -r ? -r : t;
          }
          function p(t, r) {
            for (var e = 0, n = 0; n < t.length; n++)
              e += Math.pow(t[n] - r[n], 2);
            return e;
          }
          function w(t, r) {
            var e = l.linear(0, 3 * t, 300).map(function (t) {
                return t < r ? 1 : t;
              }),
              n = l.zeros(e.length).map(function (n, i) {
                return e[i] >= r ? Math.exp(-(e[i] - r) / t) : n;
              }),
              i = f(
                { x: e, y: n },
                function (t) {
                  var r = o(t, 2),
                    e = r[0],
                    n = r[1];
                  return function (t) {
                    return 1 / (1 + e * Math.pow(t, 2 * n));
                  };
                },
                {
                  damping: 1.5,
                  initialValues: [0.5, 0.5],
                  gradientDifference: 0.1,
                  maxIterations: 100,
                  errorTolerance: 0.01,
                }
              ).parameterValues,
              s = o(i, 2);
            return { a: s[0], b: s[1] };
          }
          function d(t, r, e, n) {
            return (
              void 0 === e && (e = 1),
              void 0 === n && (n = 5),
              t.map(function (t, i, o) {
                return -1 === r[i] || -1 === r[o]
                  ? t * Math.exp(-e)
                  : r[i] !== r[o]
                  ? t * Math.exp(-n)
                  : t;
              })
            );
          }
          function y(t) {
            t = a.normalize(t, "max");
            var r = a.transpose(t),
              e = a.pairwiseMultiply(r, t);
            return (t = a.add(t, a.subtract(r, e))), a.eliminateZeros(t);
          }
          (r.findABParams = w),
            (r.fastIntersection = d),
            (r.resetLocalConnectivity = y);
        },
        function (t, r, e) {
          "use strict";
          var n,
            i =
              (this && this.__read) ||
              function (t, r) {
                var e = "function" == typeof Symbol && t[Symbol.iterator];
                if (!e) return t;
                var n,
                  i,
                  o = e.call(t),
                  s = [];
                try {
                  for (; (void 0 === r || r-- > 0) && !(n = o.next()).done; )
                    s.push(n.value);
                } catch (t) {
                  i = { error: t };
                } finally {
                  try {
                    n && !n.done && (e = o.return) && e.call(o);
                  } finally {
                    if (i) throw i.error;
                  }
                }
                return s;
              },
            o =
              (this && this.__spread) ||
              function () {
                for (var t = [], r = 0; r < arguments.length; r++)
                  t = t.concat(i(arguments[r]));
                return t;
              },
            s =
              (this && this.__values) ||
              function (t) {
                var r = "function" == typeof Symbol && t[Symbol.iterator],
                  e = 0;
                return r
                  ? r.call(t)
                  : {
                      next: function () {
                        return (
                          t && e >= t.length && (t = void 0),
                          { value: t && t[e++], done: !t }
                        );
                      },
                    };
              };
          Object.defineProperty(r, "__esModule", { value: !0 });
          var a = e(1),
            h = (function () {
              function t(t, r, e, n) {
                (this.entries = new Map()),
                  (this.nRows = 0),
                  (this.nCols = 0),
                  (this.rows = o(t)),
                  (this.cols = o(r)),
                  (this.values = o(e));
                for (var i = 0; i < e.length; i++) {
                  var s = this.makeKey(this.rows[i], this.cols[i]);
                  this.entries.set(s, i);
                }
                (this.nRows = n[0]), (this.nCols = n[0]);
              }
              return (
                (t.prototype.makeKey = function (t, r) {
                  return t + ":" + r;
                }),
                (t.prototype.checkDims = function (t, r) {
                  if (!(t < this.nRows && r < this.nCols))
                    throw new Error("array index out of bounds");
                }),
                (t.prototype.set = function (t, r, e) {
                  this.checkDims(t, r);
                  var n = this.makeKey(t, r);
                  if (this.entries.has(n)) {
                    var i = this.entries.get(n);
                    this.values[i] = e;
                  } else
                    this.rows.push(t),
                      this.cols.push(r),
                      this.values.push(e),
                      this.entries.set(n, this.values.length - 1);
                }),
                (t.prototype.get = function (t, r, e) {
                  void 0 === e && (e = 0), this.checkDims(t, r);
                  var n = this.makeKey(t, r);
                  if (this.entries.has(n)) {
                    var i = this.entries.get(n);
                    return this.values[i];
                  }
                  return e;
                }),
                (t.prototype.getDims = function () {
                  return [this.nRows, this.nCols];
                }),
                (t.prototype.getRows = function () {
                  return o(this.rows);
                }),
                (t.prototype.getCols = function () {
                  return o(this.cols);
                }),
                (t.prototype.getValues = function () {
                  return o(this.values);
                }),
                (t.prototype.forEach = function (t) {
                  for (var r = 0; r < this.values.length; r++)
                    t(this.values[r], this.rows[r], this.cols[r]);
                }),
                (t.prototype.map = function (r) {
                  for (var e = [], n = 0; n < this.values.length; n++)
                    e.push(r(this.values[n], this.rows[n], this.cols[n]));
                  var i = [this.nRows, this.nCols];
                  return new t(this.rows, this.cols, e, i);
                }),
                (t.prototype.toArray = function () {
                  for (
                    var t = this,
                      r = a.empty(this.nRows).map(function () {
                        return a.zeros(t.nCols);
                      }),
                      e = 0;
                    e < this.values.length;
                    e++
                  )
                    r[this.rows[e]][this.cols[e]] = this.values[e];
                  return r;
                }),
                t
              );
            })();
          (r.SparseMatrix = h),
            (r.transpose = function (t) {
              var r = [],
                e = [],
                n = [];
              t.forEach(function (t, i, o) {
                r.push(i), e.push(o), n.push(t);
              });
              var i = [t.nCols, t.nRows];
              return new h(e, r, n, i);
            }),
            (r.identity = function (t) {
              for (
                var r = i(t, 1)[0], e = new h([], [], [], t), n = 0;
                n < r;
                n++
              )
                e.set(n, n, 1);
              return e;
            }),
            (r.pairwiseMultiply = function (t, r) {
              return l(t, r, function (t, r) {
                return t * r;
              });
            }),
            (r.add = function (t, r) {
              return l(t, r, function (t, r) {
                return t + r;
              });
            }),
            (r.subtract = function (t, r) {
              return l(t, r, function (t, r) {
                return t - r;
              });
            }),
            (r.multiplyScalar = function (t, r) {
              return t.map(function (t) {
                return t * r;
              });
            }),
            (r.eliminateZeros = function (t) {
              for (
                var r = new Set(),
                  e = t.getValues(),
                  n = t.getRows(),
                  i = t.getCols(),
                  o = 0;
                o < e.length;
                o++
              )
                0 === e[o] && r.add(o);
              var s = function (t, e) {
                  return !r.has(e);
                },
                a = e.filter(s),
                u = n.filter(s),
                l = i.filter(s);
              return new h(u, l, a, t.getDims());
            }),
            (r.normalize = function (t, r) {
              var e, n;
              void 0 === r && (r = "l2");
              var i = u[r],
                o = new Map();
              t.forEach(function (t, r, e) {
                var n = o.get(r) || [];
                n.push(e), o.set(r, n);
              });
              var a = new h([], [], [], t.getDims()),
                l = function (r) {
                  for (
                    var e = o.get(r).sort(),
                      n = e.map(function (e) {
                        return t.get(r, e);
                      }),
                      s = i(n),
                      h = 0;
                    h < s.length;
                    h++
                  )
                    a.set(r, e[h], s[h]);
                };
              try {
                for (var f = s(o.keys()), c = f.next(); !c.done; c = f.next())
                  l(c.value);
              } catch (t) {
                e = { error: t };
              } finally {
                try {
                  c && !c.done && (n = f.return) && n.call(f);
                } finally {
                  if (e) throw e.error;
                }
              }
              return a;
            });
          var u =
            (((n = {}).max = function (t) {
              for (var r = -1 / 0, e = 0; e < t.length; e++)
                r = t[e] > r ? t[e] : r;
              return t.map(function (t) {
                return t / r;
              });
            }),
            (n.l1 = function (t) {
              for (var r = 0, e = 0; e < t.length; e++) r += t[e];
              return t.map(function (t) {
                return t / r;
              });
            }),
            (n.l2 = function (t) {
              for (var r = 0, e = 0; e < t.length; e++) r += Math.pow(t[e], 2);
              return t.map(function (t) {
                return Math.sqrt(Math.pow(t, 2) / r);
              });
            }),
            n);
          function l(t, r, e) {
            for (
              var n = new Set(),
                i = [],
                o = [],
                s = [],
                a = function (n, a) {
                  i.push(n), o.push(a);
                  var h = e(t.get(n, a), r.get(n, a));
                  s.push(h);
                },
                u = t.getValues(),
                l = t.getRows(),
                f = t.getCols(),
                c = 0;
              c < u.length;
              c++
            ) {
              var m = (w = l[c]) + ":" + (d = f[c]);
              n.add(m), a(w, d);
            }
            var g = r.getValues(),
              v = r.getRows(),
              p = r.getCols();
            for (c = 0; c < g.length; c++) {
              var w, d;
              m = (w = v[c]) + ":" + (d = p[c]);
              n.has(m) || a(w, d);
            }
            var y = [t.nRows, t.nCols];
            return new h(i, o, s, y);
          }
        },
        function (t, r, e) {
          "use strict";
          Object.defineProperty(r, "__esModule", { value: !0 });
          var n = e(6),
            i = e(1);
          r.makeNNDescent = function (t, r) {
            return function (e, o, s, a, h, u, l, f) {
              void 0 === a && (a = 10),
                void 0 === h && (h = 50),
                void 0 === u && (u = 0.001),
                void 0 === l && (l = 0.5),
                void 0 === f && (f = !0);
              for (
                var c = e.length, m = n.makeHeap(e.length, s), g = 0;
                g < e.length;
                g++
              )
                for (
                  var v = n.rejectionSample(s, e.length, r), p = 0;
                  p < v.length;
                  p++
                ) {
                  var w = t(e[g], e[v[p]]);
                  n.heapPush(m, g, w, v[p], 1), n.heapPush(m, v[p], w, g, 1);
                }
              if (f)
                for (var d = 0; d < o.length; d++)
                  for (g = 0; g < o[d].length && !(o[d][g] < 0); g++)
                    for (p = g + 1; p < o[d].length && !(o[d][p] < 0); p++)
                      (w = t(e[o[d][g]], e[o[d][p]])),
                        n.heapPush(m, o[d][g], w, o[d][p], 1),
                        n.heapPush(m, o[d][p], w, o[d][g], 1);
              for (d = 0; d < a; d++) {
                var y = n.buildCandidates(m, c, s, h, r),
                  b = 0;
                for (g = 0; g < c; g++)
                  for (p = 0; p < h; p++) {
                    var M = Math.floor(y[0][g][p]);
                    if (!(M < 0 || i.tauRand(r) < l))
                      for (var x = 0; x < h; x++) {
                        var S = Math.floor(y[0][g][x]),
                          E = y[2][g][p],
                          R = y[2][g][x];
                        S < 0 ||
                          (!E && !R) ||
                          ((w = t(e[M], e[S])),
                          (b += n.heapPush(m, M, w, S, 1)),
                          (b += n.heapPush(m, S, w, M, 1)));
                      }
                  }
                if (b <= u * s * e.length) break;
              }
              return n.deheapSort(m);
            };
          };
        },
        function (t, r, e) {
          "use strict";
          Object.defineProperty(r, "__esModule", { value: !0 });
          var n = e(1);
          function i(t, r) {
            var e = function (e) {
                return n.empty(t).map(function () {
                  return n.filled(r, e);
                });
              },
              i = [];
            return i.push(e(-1)), i.push(e(1 / 0)), i.push(e(0)), i;
          }
          function o(t, r, e, n, i) {
            r = Math.floor(r);
            var o = t[0][r],
              s = t[1][r],
              a = t[2][r];
            if (e >= s[0]) return 0;
            for (var h = 0; h < o.length; h++) if (n === o[h]) return 0;
            (s[0] = e), (o[0] = n), (a[0] = i);
            for (var u = 0, l = 0; ; ) {
              var f = 2 * u + 1,
                c = f + 1,
                m = t[0][0].length;
              if (f >= m) break;
              if (c >= m) {
                if (!(s[f] > e)) break;
                l = f;
              } else if (s[f] >= s[c]) {
                if (!(e < s[f])) break;
                l = f;
              } else {
                if (!(e < s[c])) break;
                l = c;
              }
              (s[u] = s[l]), (o[u] = o[l]), (a[u] = a[l]), (u = l);
            }
            return (s[u] = e), (o[u] = n), (a[u] = i), 1;
          }
          function s(t, r, e, n) {
            for (; 2 * n + 1 < e; ) {
              var i = 2 * n + 1,
                o = i + 1,
                s = n;
              if (
                (t[s] < t[i] && (s = i),
                o < e && t[s] < t[o] && (s = o),
                s === n)
              )
                break;
              var a = t[n];
              (t[n] = t[s]), (t[s] = a);
              var h = r[n];
              (r[n] = r[s]), (r[s] = h), (n = s);
            }
          }
          (r.makeHeap = i),
            (r.rejectionSample = function (t, r, e) {
              for (var i = n.zeros(t), o = 0; o < t; o++) {
                for (var s = !0, a = 0; s; ) {
                  a = n.tauRandInt(r, e);
                  for (var h = !1, u = 0; u < o; u++)
                    if (a === i[u]) {
                      h = !0;
                      break;
                    }
                  h || (s = !1);
                }
                i[o] = a;
              }
              return i;
            }),
            (r.heapPush = o),
            (r.buildCandidates = function (t, r, e, s, a) {
              for (var h = i(r, s), u = 0; u < r; u++)
                for (var l = 0; l < e; l++)
                  if (!(t[0][u][l] < 0)) {
                    var f = t[0][u][l],
                      c = t[2][u][l],
                      m = n.tauRand(a);
                    o(h, u, m, f, c), o(h, f, m, u, c), (t[2][u][l] = 0);
                  }
              return h;
            }),
            (r.deheapSort = function (t) {
              for (var r = t[0], e = t[1], n = 0; n < r.length; n++)
                for (var i = r[n], o = e[n], a = 0; a < i.length - 1; a++) {
                  var h = i.length - a - 1,
                    u = o.length - a - 1,
                    l = i[0];
                  (i[0] = i[h]), (i[h] = l);
                  var f = o[0];
                  (o[0] = o[u]), (o[u] = f), s(o, i, u, 0);
                }
              return { indices: r, weights: e };
            });
        },
        function (t, r, e) {
          "use strict";
          var n =
              (this && this.__read) ||
              function (t, r) {
                var e = "function" == typeof Symbol && t[Symbol.iterator];
                if (!e) return t;
                var n,
                  i,
                  o = e.call(t),
                  s = [];
                try {
                  for (; (void 0 === r || r-- > 0) && !(n = o.next()).done; )
                    s.push(n.value);
                } catch (t) {
                  i = { error: t };
                } finally {
                  try {
                    n && !n.done && (e = o.return) && e.call(o);
                  } finally {
                    if (i) throw i.error;
                  }
                }
                return s;
              },
            i =
              (this && this.__spread) ||
              function () {
                for (var t = [], r = 0; r < arguments.length; r++)
                  t = t.concat(n(arguments[r]));
                return t;
              },
            o =
              (this && this.__values) ||
              function (t) {
                var r = "function" == typeof Symbol && t[Symbol.iterator],
                  e = 0;
                return r
                  ? r.call(t)
                  : {
                      next: function () {
                        return (
                          t && e >= t.length && (t = void 0),
                          { value: t && t[e++], done: !t }
                        );
                      },
                    };
              };
          Object.defineProperty(r, "__esModule", { value: !0 });
          var s = e(1),
            a = (function () {
              return function (t, r, e, n) {
                (this.hyperplanes = t),
                  (this.offsets = r),
                  (this.children = e),
                  (this.indices = n);
              };
            })();
          (r.FlatTree = a),
            (r.makeForest = function (t, r, e, n) {
              var o = Math.max(10, r);
              return s
                .range(e)
                .map(function (r, e) {
                  return (function (t, r, e, n) {
                    void 0 === r && (r = 30);
                    var i = s.range(t.length);
                    return (function t(r, e, n, i, o) {
                      if ((void 0 === n && (n = 30), e.length > n)) {
                        var a = (function (t, r, e) {
                            var n = t[0].length,
                              i = s.tauRandInt(r.length, e),
                              o = s.tauRandInt(r.length, e);
                            o = (o += i === o ? 1 : 0) % r.length;
                            for (
                              var a = r[i],
                                h = r[o],
                                u = 0,
                                l = s.zeros(n),
                                f = 0;
                              f < l.length;
                              f++
                            )
                              (l[f] = t[a][f] - t[h][f]),
                                (u -= (l[f] * (t[a][f] + t[h][f])) / 2);
                            for (
                              var c = 0, m = 0, g = s.zeros(r.length), f = 0;
                              f < r.length;
                              f++
                            ) {
                              for (var v = u, p = 0; p < n; p++)
                                v += l[p] * t[r[f]][p];
                              0 === v
                                ? ((g[f] = s.tauRandInt(2, e)),
                                  0 === g[f] ? (c += 1) : (m += 1))
                                : v > 0
                                ? ((g[f] = 0), (c += 1))
                                : ((g[f] = 1), (m += 1));
                            }
                            var w = s.zeros(c),
                              d = s.zeros(m);
                            for (var f in ((c = 0), (m = 0), s.range(g.length)))
                              0 === g[f]
                                ? ((w[c] = r[f]), (c += 1))
                                : ((d[m] = r[f]), (m += 1));
                            return {
                              indicesLeft: w,
                              indicesRight: d,
                              hyperplane: l,
                              offset: u,
                            };
                          })(r, e, o),
                          h = a.indicesLeft,
                          u = a.indicesRight,
                          l = a.hyperplane,
                          f = a.offset,
                          c = t(r, h, n, i + 1, o),
                          m = t(r, u, n, i + 1, o),
                          g = {
                            leftChild: c,
                            rightChild: m,
                            isLeaf: !1,
                            hyperplane: l,
                            offset: f,
                          };
                        return g;
                      }
                      var g = { indices: e, isLeaf: !0 };
                      return g;
                    })(t, i, r, e, n);
                  })(t, o, e, n);
                })
                .map(function (t) {
                  return (function (t, r) {
                    var e = (function t(r) {
                        return r.isLeaf
                          ? 1
                          : 1 + t(r.leftChild) + t(r.rightChild);
                      })(t),
                      n = (function t(r) {
                        return r.isLeaf ? 1 : t(r.leftChild) + t(r.rightChild);
                      })(t),
                      o = s.range(e).map(function () {
                        return s.zeros(t.hyperplane.length);
                      }),
                      h = s.zeros(e),
                      u = s.range(e).map(function () {
                        return [-1, -1];
                      }),
                      l = s.range(n).map(function () {
                        return s.range(r).map(function () {
                          return -1;
                        });
                      });
                    return (
                      (function t(r, e, n, o, s, a, h) {
                        var u;
                        if (r.isLeaf)
                          return (
                            (o[a][0] = -h),
                            (u = s[h]).splice.apply(
                              u,
                              i([0, r.indices.length], r.indices)
                            ),
                            { nodeNum: a, leafNum: (h += 1) }
                          );
                        (e[a] = r.hyperplane),
                          (n[a] = r.offset),
                          (o[a][0] = a + 1);
                        var l = a,
                          f = t(r.leftChild, e, n, o, s, a + 1, h);
                        return (
                          (a = f.nodeNum),
                          (h = f.leafNum),
                          (o[l][1] = a + 1),
                          {
                            nodeNum: (f = t(r.rightChild, e, n, o, s, a + 1, h))
                              .nodeNum,
                            leafNum: f.leafNum,
                          }
                        );
                      })(t, o, h, u, l, 0, 0),
                      new a(o, h, u, l)
                    );
                  })(t, o);
                });
            }),
            (r.makeLeafArray = function (t) {
              var r, e;
              if (t.length > 0) {
                var n = [];
                try {
                  for (var s = o(t), a = s.next(); !a.done; a = s.next()) {
                    var h = a.value;
                    n.push.apply(n, i(h.indices));
                  }
                } catch (t) {
                  r = { error: t };
                } finally {
                  try {
                    a && !a.done && (e = s.return) && e.call(s);
                  } finally {
                    if (r) throw r.error;
                  }
                }
                return n;
              }
              return [[-1]];
            });
        },
        function (t, r, e) {
          "use strict";
          var n = e(9);
          function i(t, r, e) {
            var n = 0;
            const i = e(r);
            for (var o = 0; o < t.x.length; o++)
              n += Math.abs(t.y[o] - i(t.x[o]));
            return n;
          }
          function o(t, r, e, i, o) {
            var s = n.Matrix.eye(r.length).mul(e * i * i),
              a = t.x.length,
              h = new Array(a);
            const u = o(r);
            for (var l = 0; l < a; l++) h[l] = u(t.x[l]);
            var f = (function (t, r, e, i, o) {
                const s = e.length,
                  a = t.x.length;
                for (var h = new Array(s), u = 0; u < s; u++) {
                  h[u] = new Array(a);
                  var l = e.concat();
                  l[u] += i;
                  for (var f = o(l), c = 0; c < a; c++)
                    h[u][c] = r[c] - f(t.x[c]);
                }
                return new n.Matrix(h);
              })(t, h, r, i, o),
              c = (function (t, r) {
                const e = t.x.length;
                for (var i = new Array(e), o = 0; o < e; o++)
                  i[o] = t.y[o] - r[o];
                return new n.Matrix([i]);
              })(t, h).transposeView(),
              m = n.inverse(s.add(f.mmul(f.transposeView())));
            return (r = (r = new n.Matrix([r])).sub(
              m.mmul(f).mmul(c).mul(i).transposeView()
            )).to1DArray();
          }
          t.exports = function (t, r, e = {}) {
            let {
              maxIterations: n = 100,
              gradientDifference: s = 0.1,
              damping: a = 0,
              errorTolerance: h = 0.01,
              initialValues: u,
            } = e;
            if (a <= 0)
              throw new Error("The damping option must be a positive number");
            if (!t.x || !t.y)
              throw new Error("The data parameter must have x and y elements");
            if (
              !Array.isArray(t.x) ||
              t.x.length < 2 ||
              !Array.isArray(t.y) ||
              t.y.length < 2
            )
              throw new Error(
                "The data parameter elements must be an array with more than 2 points"
              );
            if (t.x.length !== t.y.length)
              throw new Error(
                "The data parameter elements must have the same size"
              );
            var l = u || new Array(r.length).fill(1);
            if (!Array.isArray(l))
              throw new Error("initialValues must be an array");
            for (var f = i(t, l, r), c = f <= h, m = 0; m < n && !c; m++)
              c = (f = i(t, (l = o(t, l, a, s, r)), r)) <= h;
            return { parameterValues: l, parameterError: f, iterations: m };
          };
        },
        function (t, r, e) {
          "use strict";
          e.r(r);
          var n = e(0),
            i = e.n(n);
          var o = function (t) {
            if (!i()(t)) throw new TypeError("input must be an array");
            if (0 === t.length) throw new TypeError("input must not be empty");
            for (var r = t[0], e = 1; e < t.length; e++) t[e] > r && (r = t[e]);
            return r;
          };
          var s = function (t) {
            if (!i()(t)) throw new TypeError("input must be an array");
            if (0 === t.length) throw new TypeError("input must not be empty");
            for (var r = t[0], e = 1; e < t.length; e++) t[e] < r && (r = t[e]);
            return r;
          };
          var a = function (t) {
            var r,
              e =
                arguments.length > 1 && void 0 !== arguments[1]
                  ? arguments[1]
                  : {};
            if (!i()(t)) throw new TypeError("input must be an array");
            if (0 === t.length) throw new TypeError("input must not be empty");
            if (void 0 !== e.output) {
              if (!i()(e.output))
                throw new TypeError(
                  "output option must be an array if specified"
                );
              r = e.output;
            } else r = new Array(t.length);
            var n = s(t),
              a = o(t);
            if (n === a)
              throw new RangeError(
                "minimum and maximum input values are equal. Cannot rescale a constant array"
              );
            var h = e.min,
              u = void 0 === h ? (e.autoMinMax ? n : 0) : h,
              l = e.max,
              f = void 0 === l ? (e.autoMinMax ? a : 1) : l;
            if (u >= f)
              throw new RangeError(
                "min option must be smaller than max option"
              );
            for (var c = (f - u) / (a - n), m = 0; m < t.length; m++)
              r[m] = (t[m] - n) * c + u;
            return r;
          };
          class h {
            constructor(t) {
              var r,
                e,
                n,
                i,
                o,
                s,
                a,
                h,
                u,
                l = (t = P.checkMatrix(t)).clone(),
                f = l.rows,
                c = l.columns,
                m = new Array(f),
                g = 1;
              for (r = 0; r < f; r++) m[r] = r;
              for (h = new Array(f), e = 0; e < c; e++) {
                for (r = 0; r < f; r++) h[r] = l.get(r, e);
                for (r = 0; r < f; r++) {
                  for (u = Math.min(r, e), o = 0, n = 0; n < u; n++)
                    o += l.get(r, n) * h[n];
                  (h[r] -= o), l.set(r, e, h[r]);
                }
                for (i = e, r = e + 1; r < f; r++)
                  Math.abs(h[r]) > Math.abs(h[i]) && (i = r);
                if (i !== e) {
                  for (n = 0; n < c; n++)
                    (s = l.get(i, n)), l.set(i, n, l.get(e, n)), l.set(e, n, s);
                  (a = m[i]), (m[i] = m[e]), (m[e] = a), (g = -g);
                }
                if (e < f && 0 !== l.get(e, e))
                  for (r = e + 1; r < f; r++)
                    l.set(r, e, l.get(r, e) / l.get(e, e));
              }
              (this.LU = l), (this.pivotVector = m), (this.pivotSign = g);
            }
            isSingular() {
              for (var t = this.LU, r = t.columns, e = 0; e < r; e++)
                if (0 === t[e][e]) return !0;
              return !1;
            }
            solve(t) {
              t = I.checkMatrix(t);
              var r = this.LU;
              if (r.rows !== t.rows)
                throw new Error("Invalid matrix dimensions");
              if (this.isSingular()) throw new Error("LU matrix is singular");
              var e,
                n,
                i,
                o = t.columns,
                s = t.subMatrixRow(this.pivotVector, 0, o - 1),
                a = r.columns;
              for (i = 0; i < a; i++)
                for (e = i + 1; e < a; e++)
                  for (n = 0; n < o; n++) s[e][n] -= s[i][n] * r[e][i];
              for (i = a - 1; i >= 0; i--) {
                for (n = 0; n < o; n++) s[i][n] /= r[i][i];
                for (e = 0; e < i; e++)
                  for (n = 0; n < o; n++) s[e][n] -= s[i][n] * r[e][i];
              }
              return s;
            }
            get determinant() {
              var t = this.LU;
              if (!t.isSquare()) throw new Error("Matrix must be square");
              for (var r = this.pivotSign, e = t.columns, n = 0; n < e; n++)
                r *= t[n][n];
              return r;
            }
            get lowerTriangularMatrix() {
              for (
                var t = this.LU,
                  r = t.rows,
                  e = t.columns,
                  n = new I(r, e),
                  i = 0;
                i < r;
                i++
              )
                for (var o = 0; o < e; o++)
                  n[i][o] = i > o ? t[i][o] : i === o ? 1 : 0;
              return n;
            }
            get upperTriangularMatrix() {
              for (
                var t = this.LU,
                  r = t.rows,
                  e = t.columns,
                  n = new I(r, e),
                  i = 0;
                i < r;
                i++
              )
                for (var o = 0; o < e; o++) n[i][o] = i <= o ? t[i][o] : 0;
              return n;
            }
            get pivotPermutationVector() {
              return this.pivotVector.slice();
            }
          }
          function u(t, r) {
            var e = 0;
            return Math.abs(t) > Math.abs(r)
              ? ((e = r / t), Math.abs(t) * Math.sqrt(1 + e * e))
              : 0 !== r
              ? ((e = t / r), Math.abs(r) * Math.sqrt(1 + e * e))
              : 0;
          }
          function l(t, r, e) {
            for (var n = new Array(t), i = 0; i < t; i++) {
              n[i] = new Array(r);
              for (var o = 0; o < r; o++) n[i][o] = e;
            }
            return n;
          }
          class f {
            constructor(t, r = {}) {
              var e = (t = P.checkMatrix(t)).rows,
                n = t.columns;
              const {
                computeLeftSingularVectors: i = !0,
                computeRightSingularVectors: o = !0,
                autoTranspose: s = !1,
              } = r;
              var a,
                h = Boolean(i),
                f = Boolean(o),
                c = !1;
              if (e < n)
                if (s) {
                  (e = (a = t.transpose()).rows), (n = a.columns), (c = !0);
                  var m = h;
                  (h = f), (f = m);
                } else
                  (a = t.clone()),
                    console.warn(
                      "Computing SVD on a matrix with more columns than rows. Consider enabling autoTranspose"
                    );
              else a = t.clone();
              var g = Math.min(e, n),
                v = Math.min(e + 1, n),
                p = new Array(v),
                w = l(e, g, 0),
                d = l(n, n, 0),
                y = new Array(n),
                b = new Array(e),
                M = new Array(v);
              for (let t = 0; t < v; t++) M[t] = t;
              var x = Math.min(e - 1, n),
                S = Math.max(0, Math.min(n - 2, e)),
                E = Math.max(x, S);
              for (let t = 0; t < E; t++) {
                if (t < x) {
                  p[t] = 0;
                  for (let r = t; r < e; r++) p[t] = u(p[t], a[r][t]);
                  if (0 !== p[t]) {
                    a[t][t] < 0 && (p[t] = -p[t]);
                    for (let r = t; r < e; r++) a[r][t] /= p[t];
                    a[t][t] += 1;
                  }
                  p[t] = -p[t];
                }
                for (let r = t + 1; r < n; r++) {
                  if (t < x && 0 !== p[t]) {
                    let n = 0;
                    for (let i = t; i < e; i++) n += a[i][t] * a[i][r];
                    n = -n / a[t][t];
                    for (let i = t; i < e; i++) a[i][r] += n * a[i][t];
                  }
                  y[r] = a[t][r];
                }
                if (h && t < x) for (let r = t; r < e; r++) w[r][t] = a[r][t];
                if (t < S) {
                  y[t] = 0;
                  for (let r = t + 1; r < n; r++) y[t] = u(y[t], y[r]);
                  if (0 !== y[t]) {
                    y[t + 1] < 0 && (y[t] = 0 - y[t]);
                    for (let r = t + 1; r < n; r++) y[r] /= y[t];
                    y[t + 1] += 1;
                  }
                  if (((y[t] = -y[t]), t + 1 < e && 0 !== y[t])) {
                    for (let r = t + 1; r < e; r++) b[r] = 0;
                    for (let r = t + 1; r < e; r++)
                      for (let e = t + 1; e < n; e++) b[r] += y[e] * a[r][e];
                    for (let r = t + 1; r < n; r++) {
                      let n = -y[r] / y[t + 1];
                      for (let i = t + 1; i < e; i++) a[i][r] += n * b[i];
                    }
                  }
                  if (f) for (let r = t + 1; r < n; r++) d[r][t] = y[r];
                }
              }
              let R = Math.min(n, e + 1);
              if (
                (x < n && (p[x] = a[x][x]),
                e < R && (p[R - 1] = 0),
                S + 1 < R && (y[S] = a[S][R - 1]),
                (y[R - 1] = 0),
                h)
              ) {
                for (let t = x; t < g; t++) {
                  for (let r = 0; r < e; r++) w[r][t] = 0;
                  w[t][t] = 1;
                }
                for (let t = x - 1; t >= 0; t--)
                  if (0 !== p[t]) {
                    for (let r = t + 1; r < g; r++) {
                      let n = 0;
                      for (let i = t; i < e; i++) n += w[i][t] * w[i][r];
                      n = -n / w[t][t];
                      for (let i = t; i < e; i++) w[i][r] += n * w[i][t];
                    }
                    for (let r = t; r < e; r++) w[r][t] = -w[r][t];
                    w[t][t] = 1 + w[t][t];
                    for (let r = 0; r < t - 1; r++) w[r][t] = 0;
                  } else {
                    for (let r = 0; r < e; r++) w[r][t] = 0;
                    w[t][t] = 1;
                  }
              }
              if (f)
                for (let t = n - 1; t >= 0; t--) {
                  if (t < S && 0 !== y[t])
                    for (let r = t + 1; r < n; r++) {
                      let e = 0;
                      for (let i = t + 1; i < n; i++) e += d[i][t] * d[i][r];
                      e = -e / d[t + 1][t];
                      for (let i = t + 1; i < n; i++) d[i][r] += e * d[i][t];
                    }
                  for (let r = 0; r < n; r++) d[r][t] = 0;
                  d[t][t] = 1;
                }
              for (var k = R - 1, A = Number.EPSILON; R > 0; ) {
                let t, r;
                for (t = R - 2; t >= -1 && -1 !== t; t--) {
                  const r =
                    Number.MIN_VALUE + A * Math.abs(p[t] + Math.abs(p[t + 1]));
                  if (Math.abs(y[t]) <= r || Number.isNaN(y[t])) {
                    y[t] = 0;
                    break;
                  }
                }
                if (t === R - 2) r = 4;
                else {
                  let e;
                  for (e = R - 1; e >= t && e !== t; e--) {
                    let r =
                      (e !== R ? Math.abs(y[e]) : 0) +
                      (e !== t + 1 ? Math.abs(y[e - 1]) : 0);
                    if (Math.abs(p[e]) <= A * r) {
                      p[e] = 0;
                      break;
                    }
                  }
                  e === t
                    ? (r = 3)
                    : e === R - 1
                    ? (r = 1)
                    : ((r = 2), (t = e));
                }
                switch ((t++, r)) {
                  case 1: {
                    let r = y[R - 2];
                    y[R - 2] = 0;
                    for (let e = R - 2; e >= t; e--) {
                      let i = u(p[e], r),
                        o = p[e] / i,
                        s = r / i;
                      if (
                        ((p[e] = i),
                        e !== t &&
                          ((r = -s * y[e - 1]), (y[e - 1] = o * y[e - 1])),
                        f)
                      )
                        for (let t = 0; t < n; t++)
                          (i = o * d[t][e] + s * d[t][R - 1]),
                            (d[t][R - 1] = -s * d[t][e] + o * d[t][R - 1]),
                            (d[t][e] = i);
                    }
                    break;
                  }
                  case 2: {
                    let r = y[t - 1];
                    y[t - 1] = 0;
                    for (let n = t; n < R; n++) {
                      let i = u(p[n], r),
                        o = p[n] / i,
                        s = r / i;
                      if (((p[n] = i), (r = -s * y[n]), (y[n] = o * y[n]), h))
                        for (let r = 0; r < e; r++)
                          (i = o * w[r][n] + s * w[r][t - 1]),
                            (w[r][t - 1] = -s * w[r][n] + o * w[r][t - 1]),
                            (w[r][n] = i);
                    }
                    break;
                  }
                  case 3: {
                    const r = Math.max(
                        Math.abs(p[R - 1]),
                        Math.abs(p[R - 2]),
                        Math.abs(y[R - 2]),
                        Math.abs(p[t]),
                        Math.abs(y[t])
                      ),
                      i = p[R - 1] / r,
                      o = p[R - 2] / r,
                      s = y[R - 2] / r,
                      a = p[t] / r,
                      l = y[t] / r,
                      c = ((o + i) * (o - i) + s * s) / 2,
                      m = i * s * (i * s);
                    let g = 0;
                    (0 === c && 0 === m) ||
                      (g =
                        m /
                        (c +
                          (g =
                            c < 0
                              ? 0 - Math.sqrt(c * c + m)
                              : Math.sqrt(c * c + m))));
                    let v = (a + i) * (a - i) + g,
                      b = a * l;
                    for (let r = t; r < R - 1; r++) {
                      let i = u(v, b);
                      0 === i && (i = Number.MIN_VALUE);
                      let o = v / i,
                        s = b / i;
                      if (
                        (r !== t && (y[r - 1] = i),
                        (v = o * p[r] + s * y[r]),
                        (y[r] = o * y[r] - s * p[r]),
                        (b = s * p[r + 1]),
                        (p[r + 1] = o * p[r + 1]),
                        f)
                      )
                        for (let t = 0; t < n; t++)
                          (i = o * d[t][r] + s * d[t][r + 1]),
                            (d[t][r + 1] = -s * d[t][r] + o * d[t][r + 1]),
                            (d[t][r] = i);
                      if (
                        (0 === (i = u(v, b)) && (i = Number.MIN_VALUE),
                        (o = v / i),
                        (s = b / i),
                        (p[r] = i),
                        (v = o * y[r] + s * p[r + 1]),
                        (p[r + 1] = -s * y[r] + o * p[r + 1]),
                        (b = s * y[r + 1]),
                        (y[r + 1] = o * y[r + 1]),
                        h && r < e - 1)
                      )
                        for (let t = 0; t < e; t++)
                          (i = o * w[t][r] + s * w[t][r + 1]),
                            (w[t][r + 1] = -s * w[t][r] + o * w[t][r + 1]),
                            (w[t][r] = i);
                    }
                    (y[R - 2] = v), 1;
                    break;
                  }
                  case 4:
                    if (p[t] <= 0 && ((p[t] = p[t] < 0 ? -p[t] : 0), f))
                      for (let r = 0; r <= k; r++) d[r][t] = -d[r][t];
                    for (; t < k && !(p[t] >= p[t + 1]); ) {
                      let r = p[t];
                      if (((p[t] = p[t + 1]), (p[t + 1] = r), f && t < n - 1))
                        for (let e = 0; e < n; e++)
                          (r = d[e][t + 1]),
                            (d[e][t + 1] = d[e][t]),
                            (d[e][t] = r);
                      if (h && t < e - 1)
                        for (let n = 0; n < e; n++)
                          (r = w[n][t + 1]),
                            (w[n][t + 1] = w[n][t]),
                            (w[n][t] = r);
                      t++;
                    }
                    0, R--;
                }
              }
              if (c) {
                var N = d;
                (d = w), (w = N);
              }
              (this.m = e),
                (this.n = n),
                (this.s = p),
                (this.U = w),
                (this.V = d);
            }
            solve(t) {
              var r = t,
                e = this.threshold,
                n = this.s.length,
                i = I.zeros(n, n);
              for (let t = 0; t < n; t++)
                Math.abs(this.s[t]) <= e
                  ? (i[t][t] = 0)
                  : (i[t][t] = 1 / this.s[t]);
              var o = this.U,
                s = this.rightSingularVectors,
                a = s.mmul(i),
                h = s.rows,
                u = o.length,
                l = I.zeros(h, u);
              for (let t = 0; t < h; t++)
                for (let r = 0; r < u; r++) {
                  let e = 0;
                  for (let i = 0; i < n; i++) e += a[t][i] * o[r][i];
                  l[t][r] = e;
                }
              return l.mmul(r);
            }
            solveForDiagonal(t) {
              return this.solve(I.diag(t));
            }
            inverse() {
              var t = this.V,
                r = this.threshold,
                e = t.length,
                n = t[0].length,
                i = new I(e, this.s.length);
              for (let o = 0; o < e; o++)
                for (let e = 0; e < n; e++)
                  Math.abs(this.s[e]) > r
                    ? (i[o][e] = t[o][e] / this.s[e])
                    : (i[o][e] = 0);
              var o = this.U,
                s = o.length,
                a = o[0].length,
                h = new I(e, s);
              for (let t = 0; t < e; t++)
                for (let r = 0; r < s; r++) {
                  let e = 0;
                  for (let n = 0; n < a; n++) e += i[t][n] * o[r][n];
                  h[t][r] = e;
                }
              return h;
            }
            get condition() {
              return this.s[0] / this.s[Math.min(this.m, this.n) - 1];
            }
            get norm2() {
              return this.s[0];
            }
            get rank() {
              for (
                var t = Math.max(this.m, this.n) * this.s[0] * Number.EPSILON,
                  r = 0,
                  e = this.s,
                  n = 0,
                  i = e.length;
                n < i;
                n++
              )
                e[n] > t && r++;
              return r;
            }
            get diagonal() {
              return this.s;
            }
            get threshold() {
              return (
                (Number.EPSILON / 2) * Math.max(this.m, this.n) * this.s[0]
              );
            }
            get leftSingularVectors() {
              return I.isMatrix(this.U) || (this.U = new I(this.U)), this.U;
            }
            get rightSingularVectors() {
              return I.isMatrix(this.V) || (this.V = new I(this.V)), this.V;
            }
            get diagonalMatrix() {
              return I.diag(this.s);
            }
          }
          function c(t, r, e) {
            var n = e ? t.rows : t.rows - 1;
            if (r < 0 || r > n) throw new RangeError("Row index out of range");
          }
          function m(t, r, e) {
            var n = e ? t.columns : t.columns - 1;
            if (r < 0 || r > n)
              throw new RangeError("Column index out of range");
          }
          function g(t, r) {
            if ((r.to1DArray && (r = r.to1DArray()), r.length !== t.columns))
              throw new RangeError(
                "vector size must be the same as the number of columns"
              );
            return r;
          }
          function v(t, r) {
            if ((r.to1DArray && (r = r.to1DArray()), r.length !== t.rows))
              throw new RangeError(
                "vector size must be the same as the number of rows"
              );
            return r;
          }
          function p(t, r, e) {
            return { row: w(t, r), column: d(t, e) };
          }
          function w(t, r) {
            if ("object" != typeof r)
              throw new TypeError("unexpected type for row indices");
            if (r.some((r) => r < 0 || r >= t.rows))
              throw new RangeError("row indices are out of range");
            return Array.isArray(r) || (r = Array.from(r)), r;
          }
          function d(t, r) {
            if ("object" != typeof r)
              throw new TypeError("unexpected type for column indices");
            if (r.some((r) => r < 0 || r >= t.columns))
              throw new RangeError("column indices are out of range");
            return Array.isArray(r) || (r = Array.from(r)), r;
          }
          function y(t, r, e, n, i) {
            if (5 !== arguments.length)
              throw new RangeError("expected 4 arguments");
            if (
              (b("startRow", r),
              b("endRow", e),
              b("startColumn", n),
              b("endColumn", i),
              r > e ||
                n > i ||
                r < 0 ||
                r >= t.rows ||
                e < 0 ||
                e >= t.rows ||
                n < 0 ||
                n >= t.columns ||
                i < 0 ||
                i >= t.columns)
            )
              throw new RangeError("Submatrix indices are out of range");
          }
          function b(t, r) {
            if ("number" != typeof r)
              throw new TypeError(`${t} must be a number`);
          }
          class M extends C() {
            constructor(t, r, e) {
              super(), (this.matrix = t), (this.rows = r), (this.columns = e);
            }
            static get [Symbol.species]() {
              return I;
            }
          }
          class x extends M {
            constructor(t) {
              super(t, t.columns, t.rows);
            }
            set(t, r, e) {
              return this.matrix.set(r, t, e), this;
            }
            get(t, r) {
              return this.matrix.get(r, t);
            }
          }
          class S extends M {
            constructor(t, r) {
              super(t, 1, t.columns), (this.row = r);
            }
            set(t, r, e) {
              return this.matrix.set(this.row, r, e), this;
            }
            get(t, r) {
              return this.matrix.get(this.row, r);
            }
          }
          class E extends M {
            constructor(t, r, e, n, i) {
              y(t, r, e, n, i),
                super(t, e - r + 1, i - n + 1),
                (this.startRow = r),
                (this.startColumn = n);
            }
            set(t, r, e) {
              return (
                this.matrix.set(this.startRow + t, this.startColumn + r, e),
                this
              );
            }
            get(t, r) {
              return this.matrix.get(this.startRow + t, this.startColumn + r);
            }
          }
          class R extends M {
            constructor(t, r, e) {
              var n = p(t, r, e);
              super(t, n.row.length, n.column.length),
                (this.rowIndices = n.row),
                (this.columnIndices = n.column);
            }
            set(t, r, e) {
              return (
                this.matrix.set(this.rowIndices[t], this.columnIndices[r], e),
                this
              );
            }
            get(t, r) {
              return this.matrix.get(this.rowIndices[t], this.columnIndices[r]);
            }
          }
          class k extends M {
            constructor(t, r) {
              super(t, (r = w(t, r)).length, t.columns), (this.rowIndices = r);
            }
            set(t, r, e) {
              return this.matrix.set(this.rowIndices[t], r, e), this;
            }
            get(t, r) {
              return this.matrix.get(this.rowIndices[t], r);
            }
          }
          class A extends M {
            constructor(t, r) {
              (r = d(t, r)),
                super(t, t.rows, r.length),
                (this.columnIndices = r);
            }
            set(t, r, e) {
              return this.matrix.set(t, this.columnIndices[r], e), this;
            }
            get(t, r) {
              return this.matrix.get(t, this.columnIndices[r]);
            }
          }
          class N extends M {
            constructor(t, r) {
              super(t, t.rows, 1), (this.column = r);
            }
            set(t, r, e) {
              return this.matrix.set(t, this.column, e), this;
            }
            get(t) {
              return this.matrix.get(t, this.column);
            }
          }
          class V extends M {
            constructor(t) {
              super(t, t.rows, t.columns);
            }
            set(t, r, e) {
              return this.matrix.set(this.rows - t - 1, r, e), this;
            }
            get(t, r) {
              return this.matrix.get(this.rows - t - 1, r);
            }
          }
          class z extends M {
            constructor(t) {
              super(t, t.rows, t.columns);
            }
            set(t, r, e) {
              return this.matrix.set(t, this.columns - r - 1, e), this;
            }
            get(t, r) {
              return this.matrix.get(t, this.columns - r - 1);
            }
          }
          function C(t) {
            void 0 === t && (t = Object);
            class r extends t {
              static get [Symbol.species]() {
                return this;
              }
              static from1DArray(t, r, e) {
                if (t * r !== e.length)
                  throw new RangeError(
                    "Data length does not match given dimensions"
                  );
                for (var n = new this(t, r), i = 0; i < t; i++)
                  for (var o = 0; o < r; o++) n.set(i, o, e[i * r + o]);
                return n;
              }
              static rowVector(t) {
                for (var r = new this(1, t.length), e = 0; e < t.length; e++)
                  r.set(0, e, t[e]);
                return r;
              }
              static columnVector(t) {
                for (var r = new this(t.length, 1), e = 0; e < t.length; e++)
                  r.set(e, 0, t[e]);
                return r;
              }
              static empty(t, r) {
                return new this(t, r);
              }
              static zeros(t, r) {
                return this.empty(t, r).fill(0);
              }
              static ones(t, r) {
                return this.empty(t, r).fill(1);
              }
              static rand(t, r, e) {
                void 0 === e && (e = Math.random);
                for (var n = this.empty(t, r), i = 0; i < t; i++)
                  for (var o = 0; o < r; o++) n.set(i, o, e());
                return n;
              }
              static randInt(t, r, e, n) {
                void 0 === e && (e = 1e3), void 0 === n && (n = Math.random);
                for (var i = this.empty(t, r), o = 0; o < t; o++)
                  for (var s = 0; s < r; s++) {
                    var a = Math.floor(n() * e);
                    i.set(o, s, a);
                  }
                return i;
              }
              static eye(t, r, e) {
                void 0 === r && (r = t), void 0 === e && (e = 1);
                for (
                  var n = Math.min(t, r), i = this.zeros(t, r), o = 0;
                  o < n;
                  o++
                )
                  i.set(o, o, e);
                return i;
              }
              static diag(t, r, e) {
                var n = t.length;
                void 0 === r && (r = n), void 0 === e && (e = r);
                for (
                  var i = Math.min(n, r, e), o = this.zeros(r, e), s = 0;
                  s < i;
                  s++
                )
                  o.set(s, s, t[s]);
                return o;
              }
              static min(t, r) {
                (t = this.checkMatrix(t)), (r = this.checkMatrix(r));
                for (
                  var e = t.rows, n = t.columns, i = new this(e, n), o = 0;
                  o < e;
                  o++
                )
                  for (var s = 0; s < n; s++)
                    i.set(o, s, Math.min(t.get(o, s), r.get(o, s)));
                return i;
              }
              static max(t, r) {
                (t = this.checkMatrix(t)), (r = this.checkMatrix(r));
                for (
                  var e = t.rows, n = t.columns, i = new this(e, n), o = 0;
                  o < e;
                  o++
                )
                  for (var s = 0; s < n; s++)
                    i.set(o, s, Math.max(t.get(o, s), r.get(o, s)));
                return i;
              }
              static checkMatrix(t) {
                return r.isMatrix(t) ? t : new this(t);
              }
              static isMatrix(t) {
                return null != t && "Matrix" === t.klass;
              }
              get size() {
                return this.rows * this.columns;
              }
              apply(t) {
                if ("function" != typeof t)
                  throw new TypeError("callback must be a function");
                for (var r = this.rows, e = this.columns, n = 0; n < r; n++)
                  for (var i = 0; i < e; i++) t.call(this, n, i);
                return this;
              }
              to1DArray() {
                for (var t = new Array(this.size), r = 0; r < this.rows; r++)
                  for (var e = 0; e < this.columns; e++)
                    t[r * this.columns + e] = this.get(r, e);
                return t;
              }
              to2DArray() {
                for (var t = new Array(this.rows), r = 0; r < this.rows; r++) {
                  t[r] = new Array(this.columns);
                  for (var e = 0; e < this.columns; e++)
                    t[r][e] = this.get(r, e);
                }
                return t;
              }
              isRowVector() {
                return 1 === this.rows;
              }
              isColumnVector() {
                return 1 === this.columns;
              }
              isVector() {
                return 1 === this.rows || 1 === this.columns;
              }
              isSquare() {
                return this.rows === this.columns;
              }
              isSymmetric() {
                if (this.isSquare()) {
                  for (var t = 0; t < this.rows; t++)
                    for (var r = 0; r <= t; r++)
                      if (this.get(t, r) !== this.get(r, t)) return !1;
                  return !0;
                }
                return !1;
              }
              set(t, r, e) {
                throw new Error("set method is unimplemented");
              }
              get(t, r) {
                throw new Error("get method is unimplemented");
              }
              repeat(t, r) {
                (t = t || 1), (r = r || 1);
                for (
                  var e = new this.constructor[Symbol.species](
                      this.rows * t,
                      this.columns * r
                    ),
                    n = 0;
                  n < t;
                  n++
                )
                  for (var i = 0; i < r; i++)
                    e.setSubMatrix(this, this.rows * n, this.columns * i);
                return e;
              }
              fill(t) {
                for (var r = 0; r < this.rows; r++)
                  for (var e = 0; e < this.columns; e++) this.set(r, e, t);
                return this;
              }
              neg() {
                return this.mulS(-1);
              }
              getRow(t) {
                c(this, t);
                for (
                  var r = new Array(this.columns), e = 0;
                  e < this.columns;
                  e++
                )
                  r[e] = this.get(t, e);
                return r;
              }
              getRowVector(t) {
                return this.constructor.rowVector(this.getRow(t));
              }
              setRow(t, r) {
                c(this, t), (r = g(this, r));
                for (var e = 0; e < this.columns; e++) this.set(t, e, r[e]);
                return this;
              }
              swapRows(t, r) {
                c(this, t), c(this, r);
                for (var e = 0; e < this.columns; e++) {
                  var n = this.get(t, e);
                  this.set(t, e, this.get(r, e)), this.set(r, e, n);
                }
                return this;
              }
              getColumn(t) {
                m(this, t);
                for (var r = new Array(this.rows), e = 0; e < this.rows; e++)
                  r[e] = this.get(e, t);
                return r;
              }
              getColumnVector(t) {
                return this.constructor.columnVector(this.getColumn(t));
              }
              setColumn(t, r) {
                m(this, t), (r = v(this, r));
                for (var e = 0; e < this.rows; e++) this.set(e, t, r[e]);
                return this;
              }
              swapColumns(t, r) {
                m(this, t), m(this, r);
                for (var e = 0; e < this.rows; e++) {
                  var n = this.get(e, t);
                  this.set(e, t, this.get(e, r)), this.set(e, r, n);
                }
                return this;
              }
              addRowVector(t) {
                t = g(this, t);
                for (var r = 0; r < this.rows; r++)
                  for (var e = 0; e < this.columns; e++)
                    this.set(r, e, this.get(r, e) + t[e]);
                return this;
              }
              subRowVector(t) {
                t = g(this, t);
                for (var r = 0; r < this.rows; r++)
                  for (var e = 0; e < this.columns; e++)
                    this.set(r, e, this.get(r, e) - t[e]);
                return this;
              }
              mulRowVector(t) {
                t = g(this, t);
                for (var r = 0; r < this.rows; r++)
                  for (var e = 0; e < this.columns; e++)
                    this.set(r, e, this.get(r, e) * t[e]);
                return this;
              }
              divRowVector(t) {
                t = g(this, t);
                for (var r = 0; r < this.rows; r++)
                  for (var e = 0; e < this.columns; e++)
                    this.set(r, e, this.get(r, e) / t[e]);
                return this;
              }
              addColumnVector(t) {
                t = v(this, t);
                for (var r = 0; r < this.rows; r++)
                  for (var e = 0; e < this.columns; e++)
                    this.set(r, e, this.get(r, e) + t[r]);
                return this;
              }
              subColumnVector(t) {
                t = v(this, t);
                for (var r = 0; r < this.rows; r++)
                  for (var e = 0; e < this.columns; e++)
                    this.set(r, e, this.get(r, e) - t[r]);
                return this;
              }
              mulColumnVector(t) {
                t = v(this, t);
                for (var r = 0; r < this.rows; r++)
                  for (var e = 0; e < this.columns; e++)
                    this.set(r, e, this.get(r, e) * t[r]);
                return this;
              }
              divColumnVector(t) {
                t = v(this, t);
                for (var r = 0; r < this.rows; r++)
                  for (var e = 0; e < this.columns; e++)
                    this.set(r, e, this.get(r, e) / t[r]);
                return this;
              }
              mulRow(t, r) {
                c(this, t);
                for (var e = 0; e < this.columns; e++)
                  this.set(t, e, this.get(t, e) * r);
                return this;
              }
              mulColumn(t, r) {
                m(this, t);
                for (var e = 0; e < this.rows; e++)
                  this.set(e, t, this.get(e, t) * r);
                return this;
              }
              max() {
                for (var t = this.get(0, 0), r = 0; r < this.rows; r++)
                  for (var e = 0; e < this.columns; e++)
                    this.get(r, e) > t && (t = this.get(r, e));
                return t;
              }
              maxIndex() {
                for (
                  var t = this.get(0, 0), r = [0, 0], e = 0;
                  e < this.rows;
                  e++
                )
                  for (var n = 0; n < this.columns; n++)
                    this.get(e, n) > t &&
                      ((t = this.get(e, n)), (r[0] = e), (r[1] = n));
                return r;
              }
              min() {
                for (var t = this.get(0, 0), r = 0; r < this.rows; r++)
                  for (var e = 0; e < this.columns; e++)
                    this.get(r, e) < t && (t = this.get(r, e));
                return t;
              }
              minIndex() {
                for (
                  var t = this.get(0, 0), r = [0, 0], e = 0;
                  e < this.rows;
                  e++
                )
                  for (var n = 0; n < this.columns; n++)
                    this.get(e, n) < t &&
                      ((t = this.get(e, n)), (r[0] = e), (r[1] = n));
                return r;
              }
              maxRow(t) {
                c(this, t);
                for (var r = this.get(t, 0), e = 1; e < this.columns; e++)
                  this.get(t, e) > r && (r = this.get(t, e));
                return r;
              }
              maxRowIndex(t) {
                c(this, t);
                for (
                  var r = this.get(t, 0), e = [t, 0], n = 1;
                  n < this.columns;
                  n++
                )
                  this.get(t, n) > r && ((r = this.get(t, n)), (e[1] = n));
                return e;
              }
              minRow(t) {
                c(this, t);
                for (var r = this.get(t, 0), e = 1; e < this.columns; e++)
                  this.get(t, e) < r && (r = this.get(t, e));
                return r;
              }
              minRowIndex(t) {
                c(this, t);
                for (
                  var r = this.get(t, 0), e = [t, 0], n = 1;
                  n < this.columns;
                  n++
                )
                  this.get(t, n) < r && ((r = this.get(t, n)), (e[1] = n));
                return e;
              }
              maxColumn(t) {
                m(this, t);
                for (var r = this.get(0, t), e = 1; e < this.rows; e++)
                  this.get(e, t) > r && (r = this.get(e, t));
                return r;
              }
              maxColumnIndex(t) {
                m(this, t);
                for (
                  var r = this.get(0, t), e = [0, t], n = 1;
                  n < this.rows;
                  n++
                )
                  this.get(n, t) > r && ((r = this.get(n, t)), (e[0] = n));
                return e;
              }
              minColumn(t) {
                m(this, t);
                for (var r = this.get(0, t), e = 1; e < this.rows; e++)
                  this.get(e, t) < r && (r = this.get(e, t));
                return r;
              }
              minColumnIndex(t) {
                m(this, t);
                for (
                  var r = this.get(0, t), e = [0, t], n = 1;
                  n < this.rows;
                  n++
                )
                  this.get(n, t) < r && ((r = this.get(n, t)), (e[0] = n));
                return e;
              }
              diag() {
                for (
                  var t = Math.min(this.rows, this.columns),
                    r = new Array(t),
                    e = 0;
                  e < t;
                  e++
                )
                  r[e] = this.get(e, e);
                return r;
              }
              sum(t) {
                switch (t) {
                  case "row":
                    return (function (t) {
                      for (var r = I.zeros(t.rows, 1), e = 0; e < t.rows; ++e)
                        for (var n = 0; n < t.columns; ++n)
                          r.set(e, 0, r.get(e, 0) + t.get(e, n));
                      return r;
                    })(this);
                  case "column":
                    return (function (t) {
                      for (
                        var r = I.zeros(1, t.columns), e = 0;
                        e < t.rows;
                        ++e
                      )
                        for (var n = 0; n < t.columns; ++n)
                          r.set(0, n, r.get(0, n) + t.get(e, n));
                      return r;
                    })(this);
                  default:
                    return (function (t) {
                      for (var r = 0, e = 0; e < t.rows; e++)
                        for (var n = 0; n < t.columns; n++) r += t.get(e, n);
                      return r;
                    })(this);
                }
              }
              mean() {
                return this.sum() / this.size;
              }
              prod() {
                for (var t = 1, r = 0; r < this.rows; r++)
                  for (var e = 0; e < this.columns; e++) t *= this.get(r, e);
                return t;
              }
              norm(t = "frobenius") {
                var r = 0;
                if ("max" === t) return this.max();
                if ("frobenius" === t) {
                  for (var e = 0; e < this.rows; e++)
                    for (var n = 0; n < this.columns; n++)
                      r += this.get(e, n) * this.get(e, n);
                  return Math.sqrt(r);
                }
                throw new RangeError(`unknown norm type: ${t}`);
              }
              cumulativeSum() {
                for (var t = 0, r = 0; r < this.rows; r++)
                  for (var e = 0; e < this.columns; e++)
                    (t += this.get(r, e)), this.set(r, e, t);
                return this;
              }
              dot(t) {
                r.isMatrix(t) && (t = t.to1DArray());
                var e = this.to1DArray();
                if (e.length !== t.length)
                  throw new RangeError("vectors do not have the same size");
                for (var n = 0, i = 0; i < e.length; i++) n += e[i] * t[i];
                return n;
              }
              mmul(t) {
                (t = this.constructor.checkMatrix(t)),
                  this.columns !== t.rows &&
                    console.warn(
                      "Number of columns of left matrix are not equal to number of rows of right matrix."
                    );
                for (
                  var r = this.rows,
                    e = this.columns,
                    n = t.columns,
                    i = new this.constructor[Symbol.species](r, n),
                    o = new Array(e),
                    s = 0;
                  s < n;
                  s++
                ) {
                  for (var a = 0; a < e; a++) o[a] = t.get(a, s);
                  for (var h = 0; h < r; h++) {
                    var u = 0;
                    for (a = 0; a < e; a++) u += this.get(h, a) * o[a];
                    i.set(h, s, u);
                  }
                }
                return i;
              }
              strassen2x2(t) {
                var r = new this.constructor[Symbol.species](2, 2);
                const e = this.get(0, 0),
                  n = t.get(0, 0),
                  i = this.get(0, 1),
                  o = t.get(0, 1),
                  s = this.get(1, 0),
                  a = t.get(1, 0),
                  h = this.get(1, 1),
                  u = t.get(1, 1),
                  l = (e + h) * (n + u),
                  f = (s + h) * n,
                  c = e * (o - u),
                  m = h * (a - n),
                  g = (e + i) * u,
                  v = l + m - g + (i - h) * (a + u),
                  p = c + g,
                  w = f + m,
                  d = l - f + c + (s - e) * (n + o);
                return (
                  r.set(0, 0, v),
                  r.set(0, 1, p),
                  r.set(1, 0, w),
                  r.set(1, 1, d),
                  r
                );
              }
              strassen3x3(t) {
                var r = new this.constructor[Symbol.species](3, 3);
                const e = this.get(0, 0),
                  n = this.get(0, 1),
                  i = this.get(0, 2),
                  o = this.get(1, 0),
                  s = this.get(1, 1),
                  a = this.get(1, 2),
                  h = this.get(2, 0),
                  u = this.get(2, 1),
                  l = this.get(2, 2),
                  f = t.get(0, 0),
                  c = t.get(0, 1),
                  m = t.get(0, 2),
                  g = t.get(1, 0),
                  v = t.get(1, 1),
                  p = t.get(1, 2),
                  w = t.get(2, 0),
                  d = t.get(2, 1),
                  y = t.get(2, 2),
                  b = (e - o) * (-c + v),
                  M = (-e + o + s) * (f - c + v),
                  x = (o + s) * (-f + c),
                  S = e * f,
                  E = (-e + h + u) * (f - m + p),
                  R = (-e + h) * (m - p),
                  k = (h + u) * (-f + m),
                  A = (-i + u + l) * (v + w - d),
                  N = (i - l) * (v - d),
                  V = i * w,
                  z = (u + l) * (-w + d),
                  C = (-i + s + a) * (p + w - y),
                  I = (i - a) * (p - y),
                  j = (s + a) * (-w + y),
                  P = S + V + n * g,
                  D = (e + n + i - o - s - u - l) * v + M + x + S + A + V + z,
                  _ = S + E + k + (e + n + i - s - a - h - u) * p + V + C + j,
                  L = b + s * (-f + c + g - v - p - w + y) + M + S + V + C + I,
                  O = b + M + x + S + a * d,
                  q = V + C + I + j + o * m,
                  T = S + E + R + u * (-f + m + g - v - p - w + d) + A + N + V,
                  U = A + N + V + z + h * c,
                  $ = S + E + R + k + l * y;
                return (
                  r.set(0, 0, P),
                  r.set(0, 1, D),
                  r.set(0, 2, _),
                  r.set(1, 0, L),
                  r.set(1, 1, O),
                  r.set(1, 2, q),
                  r.set(2, 0, T),
                  r.set(2, 1, U),
                  r.set(2, 2, $),
                  r
                );
              }
              mmulStrassen(t) {
                var e = this.clone(),
                  n = e.rows,
                  i = e.columns,
                  o = t.rows,
                  s = t.columns;
                function a(t, e, n) {
                  var i = t.rows,
                    o = t.columns;
                  if (i === e && o === n) return t;
                  var s = r.zeros(e, n);
                  return (s = s.setSubMatrix(t, 0, 0));
                }
                i !== o &&
                  console.warn(
                    `Multiplying ${n} x ${i} and ${o} x ${s} matrix: dimensions do not match.`
                  );
                var h = Math.max(n, o),
                  u = Math.max(i, s);
                return (function t(e, n, i, o) {
                  if (i <= 512 || o <= 512) return e.mmul(n);
                  i % 2 == 1 && o % 2 == 1
                    ? ((e = a(e, i + 1, o + 1)), (n = a(n, i + 1, o + 1)))
                    : i % 2 == 1
                    ? ((e = a(e, i + 1, o)), (n = a(n, i + 1, o)))
                    : o % 2 == 1 &&
                      ((e = a(e, i, o + 1)), (n = a(n, i, o + 1)));
                  var s = parseInt(e.rows / 2, 10),
                    h = parseInt(e.columns / 2, 10),
                    u = e.subMatrix(0, s - 1, 0, h - 1),
                    l = n.subMatrix(0, s - 1, 0, h - 1),
                    f = e.subMatrix(0, s - 1, h, e.columns - 1),
                    c = n.subMatrix(0, s - 1, h, n.columns - 1),
                    m = e.subMatrix(s, e.rows - 1, 0, h - 1),
                    g = n.subMatrix(s, n.rows - 1, 0, h - 1),
                    v = e.subMatrix(s, e.rows - 1, h, e.columns - 1),
                    p = n.subMatrix(s, n.rows - 1, h, n.columns - 1),
                    w = t(r.add(u, v), r.add(l, p), s, h),
                    d = t(r.add(m, v), l, s, h),
                    y = t(u, r.sub(c, p), s, h),
                    b = t(v, r.sub(g, l), s, h),
                    M = t(r.add(u, f), p, s, h),
                    x = t(r.sub(m, u), r.add(l, c), s, h),
                    S = t(r.sub(f, v), r.add(g, p), s, h),
                    E = r.add(w, b);
                  E.sub(M), E.add(S);
                  var R = r.add(y, M),
                    k = r.add(d, b),
                    A = r.sub(w, d);
                  A.add(y), A.add(x);
                  var N = r.zeros(2 * E.rows, 2 * E.columns);
                  return (N = (N = (N = (N = N.setSubMatrix(
                    E,
                    0,
                    0
                  )).setSubMatrix(R, E.rows, 0)).setSubMatrix(
                    k,
                    0,
                    E.columns
                  )).setSubMatrix(A, E.rows, E.columns)).subMatrix(
                    0,
                    i - 1,
                    0,
                    o - 1
                  );
                })((e = a(e, h, u)), (t = a(t, h, u)), h, u);
              }
              scaleRows(t, r) {
                if ((t = void 0 === t ? 0 : t) >= (r = void 0 === r ? 1 : r))
                  throw new RangeError(
                    "min should be strictly smaller than max"
                  );
                for (
                  var e = this.constructor.empty(this.rows, this.columns),
                    n = 0;
                  n < this.rows;
                  n++
                ) {
                  var i = a(this.getRow(n), { min: t, max: r });
                  e.setRow(n, i);
                }
                return e;
              }
              scaleColumns(t, r) {
                if ((t = void 0 === t ? 0 : t) >= (r = void 0 === r ? 1 : r))
                  throw new RangeError(
                    "min should be strictly smaller than max"
                  );
                for (
                  var e = this.constructor.empty(this.rows, this.columns),
                    n = 0;
                  n < this.columns;
                  n++
                ) {
                  var i = a(this.getColumn(n), { min: t, max: r });
                  e.setColumn(n, i);
                }
                return e;
              }
              kroneckerProduct(t) {
                t = this.constructor.checkMatrix(t);
                for (
                  var r = this.rows,
                    e = this.columns,
                    n = t.rows,
                    i = t.columns,
                    o = new this.constructor[Symbol.species](r * n, e * i),
                    s = 0;
                  s < r;
                  s++
                )
                  for (var a = 0; a < e; a++)
                    for (var h = 0; h < n; h++)
                      for (var u = 0; u < i; u++)
                        o[n * s + h][i * a + u] = this.get(s, a) * t.get(h, u);
                return o;
              }
              transpose() {
                for (
                  var t = new this.constructor[Symbol.species](
                      this.columns,
                      this.rows
                    ),
                    r = 0;
                  r < this.rows;
                  r++
                )
                  for (var e = 0; e < this.columns; e++)
                    t.set(e, r, this.get(r, e));
                return t;
              }
              sortRows(t) {
                void 0 === t && (t = e);
                for (var r = 0; r < this.rows; r++)
                  this.setRow(r, this.getRow(r).sort(t));
                return this;
              }
              sortColumns(t) {
                void 0 === t && (t = e);
                for (var r = 0; r < this.columns; r++)
                  this.setColumn(r, this.getColumn(r).sort(t));
                return this;
              }
              subMatrix(t, r, e, n) {
                y(this, t, r, e, n);
                for (
                  var i = new this.constructor[Symbol.species](
                      r - t + 1,
                      n - e + 1
                    ),
                    o = t;
                  o <= r;
                  o++
                )
                  for (var s = e; s <= n; s++) i[o - t][s - e] = this.get(o, s);
                return i;
              }
              subMatrixRow(t, r, e) {
                if (
                  (void 0 === r && (r = 0),
                  void 0 === e && (e = this.columns - 1),
                  r > e ||
                    r < 0 ||
                    r >= this.columns ||
                    e < 0 ||
                    e >= this.columns)
                )
                  throw new RangeError("Argument out of range");
                for (
                  var n = new this.constructor[Symbol.species](
                      t.length,
                      e - r + 1
                    ),
                    i = 0;
                  i < t.length;
                  i++
                )
                  for (var o = r; o <= e; o++) {
                    if (t[i] < 0 || t[i] >= this.rows)
                      throw new RangeError(`Row index out of range: ${t[i]}`);
                    n.set(i, o - r, this.get(t[i], o));
                  }
                return n;
              }
              subMatrixColumn(t, r, e) {
                if (
                  (void 0 === r && (r = 0),
                  void 0 === e && (e = this.rows - 1),
                  r > e || r < 0 || r >= this.rows || e < 0 || e >= this.rows)
                )
                  throw new RangeError("Argument out of range");
                for (
                  var n = new this.constructor[Symbol.species](
                      e - r + 1,
                      t.length
                    ),
                    i = 0;
                  i < t.length;
                  i++
                )
                  for (var o = r; o <= e; o++) {
                    if (t[i] < 0 || t[i] >= this.columns)
                      throw new RangeError(
                        `Column index out of range: ${t[i]}`
                      );
                    n.set(o - r, i, this.get(o, t[i]));
                  }
                return n;
              }
              setSubMatrix(t, r, e) {
                y(
                  this,
                  r,
                  r + (t = this.constructor.checkMatrix(t)).rows - 1,
                  e,
                  e + t.columns - 1
                );
                for (var n = 0; n < t.rows; n++)
                  for (var i = 0; i < t.columns; i++)
                    this[r + n][e + i] = t.get(n, i);
                return this;
              }
              selection(t, r) {
                for (
                  var e = p(this, t, r),
                    n = new this.constructor[Symbol.species](
                      t.length,
                      r.length
                    ),
                    i = 0;
                  i < e.row.length;
                  i++
                )
                  for (var o = e.row[i], s = 0; s < e.column.length; s++) {
                    var a = e.column[s];
                    n[i][s] = this.get(o, a);
                  }
                return n;
              }
              trace() {
                for (
                  var t = Math.min(this.rows, this.columns), r = 0, e = 0;
                  e < t;
                  e++
                )
                  r += this.get(e, e);
                return r;
              }
              transposeView() {
                return new x(this);
              }
              rowView(t) {
                return c(this, t), new S(this, t);
              }
              columnView(t) {
                return m(this, t), new N(this, t);
              }
              flipRowView() {
                return new V(this);
              }
              flipColumnView() {
                return new z(this);
              }
              subMatrixView(t, r, e, n) {
                return new E(this, t, r, e, n);
              }
              selectionView(t, r) {
                return new R(this, t, r);
              }
              rowSelectionView(t) {
                return new k(this, t);
              }
              columnSelectionView(t) {
                return new A(this, t);
              }
              det() {
                var t, r, e, n, i, o;
                if (this.isSquare())
                  return 2 === this.columns
                    ? ((t = this.get(0, 0)),
                      (r = this.get(0, 1)),
                      (e = this.get(1, 0)),
                      t * this.get(1, 1) - r * e)
                    : 3 === this.columns
                    ? ((n = this.selectionView([1, 2], [1, 2])),
                      (i = this.selectionView([1, 2], [0, 2])),
                      (o = this.selectionView([1, 2], [0, 1])),
                      (t = this.get(0, 0)),
                      (r = this.get(0, 1)),
                      (e = this.get(0, 2)),
                      t * n.det() - r * i.det() + e * o.det())
                    : new h(this).determinant;
                throw Error(
                  "Determinant can only be calculated for a square matrix."
                );
              }
              pseudoInverse(t) {
                void 0 === t && (t = Number.EPSILON);
                for (
                  var r = new f(this, { autoTranspose: !0 }),
                    e = r.leftSingularVectors,
                    n = r.rightSingularVectors,
                    i = r.diagonal,
                    o = 0;
                  o < i.length;
                  o++
                )
                  Math.abs(i[o]) > t ? (i[o] = 1 / i[o]) : (i[o] = 0);
                return (
                  (i = this.constructor[Symbol.species].diag(i)),
                  n.mmul(i.mmul(e.transposeView()))
                );
              }
              clone() {
                for (
                  var t = new this.constructor[Symbol.species](
                      this.rows,
                      this.columns
                    ),
                    r = 0;
                  r < this.rows;
                  r++
                )
                  for (var e = 0; e < this.columns; e++)
                    t.set(r, e, this.get(r, e));
                return t;
              }
            }
            function e(t, r) {
              return t - r;
            }
            (r.prototype.klass = "Matrix"),
              (r.random = r.rand),
              (r.diagonal = r.diag),
              (r.prototype.diagonal = r.prototype.diag),
              (r.identity = r.eye),
              (r.prototype.negate = r.prototype.neg),
              (r.prototype.tensorProduct = r.prototype.kroneckerProduct),
              (r.prototype.determinant = r.prototype.det);
            var n,
              i =
                "\n(function %name%(matrix, %args%) {\n    var newMatrix = new this[Symbol.species](matrix);\n    return newMatrix.%name%(%args%);\n})\n",
              o = eval;
            for (var s of [
              ["+", "add"],
              ["-", "sub", "subtract"],
              ["*", "mul", "multiply"],
              ["/", "div", "divide"],
              ["%", "mod", "modulus"],
              ["&", "and"],
              ["|", "or"],
              ["^", "xor"],
              ["<<", "leftShift"],
              [">>", "signPropagatingRightShift"],
              [">>>", "rightShift", "zeroFillRightShift"],
            ]) {
              var u = o(
                  F(
                    "\n(function %name%(value) {\n    if (typeof value === 'number') return this.%name%S(value);\n    return this.%name%M(value);\n})\n",
                    { name: s[1], op: s[0] }
                  )
                ),
                l = o(
                  F(
                    "\n(function %name%S(value) {\n    for (var i = 0; i < this.rows; i++) {\n        for (var j = 0; j < this.columns; j++) {\n            this.set(i, j, this.get(i, j) %op% value);\n        }\n    }\n    return this;\n})\n",
                    { name: `${s[1]}S`, op: s[0] }
                  )
                ),
                w = o(
                  F(
                    "\n(function %name%M(matrix) {\n    matrix = this.constructor.checkMatrix(matrix);\n    if (this.rows !== matrix.rows ||\n        this.columns !== matrix.columns) {\n        throw new RangeError('Matrices dimensions must be equal');\n    }\n    for (var i = 0; i < this.rows; i++) {\n        for (var j = 0; j < this.columns; j++) {\n            this.set(i, j, this.get(i, j) %op% matrix.get(i, j));\n        }\n    }\n    return this;\n})\n",
                    { name: `${s[1]}M`, op: s[0] }
                  )
                ),
                d = o(
                  F(
                    "\n(function %name%(matrix, value) {\n    var newMatrix = new this[Symbol.species](matrix);\n    return newMatrix.%name%(value);\n})\n",
                    { name: s[1] }
                  )
                );
              for (n = 1; n < s.length; n++)
                (r.prototype[s[n]] = u),
                  (r.prototype[`${s[n]}S`] = l),
                  (r.prototype[`${s[n]}M`] = w),
                  (r[s[n]] = d);
            }
            var b = [["~", "not"]];
            for (var M of ([
              "abs",
              "acos",
              "acosh",
              "asin",
              "asinh",
              "atan",
              "atanh",
              "cbrt",
              "ceil",
              "clz32",
              "cos",
              "cosh",
              "exp",
              "expm1",
              "floor",
              "fround",
              "log",
              "log1p",
              "log10",
              "log2",
              "round",
              "sign",
              "sin",
              "sinh",
              "sqrt",
              "tan",
              "tanh",
              "trunc",
            ].forEach(function (t) {
              b.push([`Math.${t}`, t]);
            }),
            b)) {
              var C = o(
                  F(
                    "\n(function %name%() {\n    for (var i = 0; i < this.rows; i++) {\n        for (var j = 0; j < this.columns; j++) {\n            this.set(i, j, %method%(this.get(i, j)));\n        }\n    }\n    return this;\n})\n",
                    { name: M[1], method: M[0] }
                  )
                ),
                j = o(
                  F(
                    "\n(function %name%(matrix) {\n    var newMatrix = new this[Symbol.species](matrix);\n    return newMatrix.%name%();\n})\n",
                    { name: M[1] }
                  )
                );
              for (n = 1; n < M.length; n++)
                (r.prototype[M[n]] = C), (r[M[n]] = j);
            }
            for (var P of [["Math.pow", 1, "pow"]]) {
              var D = "arg0";
              for (n = 1; n < P[1]; n++) D += `, arg${n}`;
              if (1 !== P[1]) {
                var _ = o(
                    F(
                      "\n(function %name%(%args%) {\n    for (var i = 0; i < this.rows; i++) {\n        for (var j = 0; j < this.columns; j++) {\n            this.set(i, j, %method%(this.get(i, j), %args%));\n        }\n    }\n    return this;\n})\n",
                      { name: P[2], method: P[0], args: D }
                    )
                  ),
                  L = o(F(i, { name: P[2], args: D }));
                for (n = 2; n < P.length; n++)
                  (r.prototype[P[n]] = _), (r[P[n]] = L);
              } else {
                var O = { name: P[2], args: D, method: P[0] },
                  q = o(
                    F(
                      "\n(function %name%(value) {\n    if (typeof value === 'number') return this.%name%S(value);\n    return this.%name%M(value);\n})\n",
                      O
                    )
                  ),
                  T = o(
                    F(
                      "\n(function %name%S(value) {\n    for (var i = 0; i < this.rows; i++) {\n        for (var j = 0; j < this.columns; j++) {\n            this.set(i, j, %method%(this.get(i, j), value));\n        }\n    }\n    return this;\n})\n",
                      O
                    )
                  ),
                  U = o(
                    F(
                      "\n(function %name%M(matrix) {\n    matrix = this.constructor.checkMatrix(matrix);\n    if (this.rows !== matrix.rows ||\n        this.columns !== matrix.columns) {\n        throw new RangeError('Matrices dimensions must be equal');\n    }\n    for (var i = 0; i < this.rows; i++) {\n        for (var j = 0; j < this.columns; j++) {\n            this.set(i, j, %method%(this.get(i, j), matrix.get(i, j)));\n        }\n    }\n    return this;\n})\n",
                      O
                    )
                  ),
                  $ = o(
                    F(
                      "\n(function %name%(matrix, %args%) {\n    var newMatrix = new this[Symbol.species](matrix);\n    return newMatrix.%name%(%args%);\n})\n",
                      O
                    )
                  );
                for (n = 2; n < P.length; n++)
                  (r.prototype[P[n]] = q),
                    (r.prototype[`${P[n]}M`] = U),
                    (r.prototype[`${P[n]}S`] = T),
                    (r[P[n]] = $);
              }
            }
            function F(t, r) {
              for (var e in r) t = t.replace(new RegExp(`%${e}%`, "g"), r[e]);
              return t;
            }
            return r;
          }
          class I extends C(Array) {
            constructor(t, r) {
              var e;
              if (1 === arguments.length && "number" == typeof t)
                return new Array(t);
              if (I.isMatrix(t)) return t.clone();
              if (Number.isInteger(t) && t > 0) {
                if ((super(t), !(Number.isInteger(r) && r > 0)))
                  throw new TypeError("nColumns must be a positive integer");
                for (e = 0; e < t; e++) this[e] = new Array(r);
              } else {
                if (!Array.isArray(t))
                  throw new TypeError(
                    "First argument must be a positive number or an array"
                  );
                {
                  const n = t;
                  if (
                    ((t = n.length),
                    "number" != typeof (r = n[0].length) || 0 === r)
                  )
                    throw new TypeError(
                      "Data must be a 2D array with at least one element"
                    );
                  for (super(t), e = 0; e < t; e++) {
                    if (n[e].length !== r)
                      throw new RangeError("Inconsistent array dimensions");
                    this[e] = [].concat(n[e]);
                  }
                }
              }
              return (this.rows = t), (this.columns = r), this;
            }
            set(t, r, e) {
              return (this[t][r] = e), this;
            }
            get(t, r) {
              return this[t][r];
            }
            removeRow(t) {
              if ((c(this, t), 1 === this.rows))
                throw new RangeError("A matrix cannot have less than one row");
              return this.splice(t, 1), (this.rows -= 1), this;
            }
            addRow(t, r) {
              return (
                void 0 === r && ((r = t), (t = this.rows)),
                c(this, t, !0),
                (r = g(this, r)),
                this.splice(t, 0, r),
                (this.rows += 1),
                this
              );
            }
            removeColumn(t) {
              if ((m(this, t), 1 === this.columns))
                throw new RangeError(
                  "A matrix cannot have less than one column"
                );
              for (var r = 0; r < this.rows; r++) this[r].splice(t, 1);
              return (this.columns -= 1), this;
            }
            addColumn(t, r) {
              void 0 === r && ((r = t), (t = this.columns)),
                m(this, t, !0),
                (r = v(this, r));
              for (var e = 0; e < this.rows; e++) this[e].splice(t, 0, r[e]);
              return (this.columns += 1), this;
            }
          }
          class j extends C() {
            constructor(t, r = {}) {
              const { rows: e = 1 } = r;
              if (t.length % e != 0)
                throw new Error(
                  "the data length is not divisible by the number of rows"
                );
              super(),
                (this.rows = e),
                (this.columns = t.length / e),
                (this.data = t);
            }
            set(t, r, e) {
              var n = this._calculateIndex(t, r);
              return (this.data[n] = e), this;
            }
            get(t, r) {
              var e = this._calculateIndex(t, r);
              return this.data[e];
            }
            _calculateIndex(t, r) {
              return t * this.columns + r;
            }
            static get [Symbol.species]() {
              return I;
            }
          }
          class P extends C() {
            constructor(t) {
              super(),
                (this.data = t),
                (this.rows = t.length),
                (this.columns = t[0].length);
            }
            set(t, r, e) {
              return (this.data[t][r] = e), this;
            }
            get(t, r) {
              return this.data[t][r];
            }
            static get [Symbol.species]() {
              return I;
            }
          }
          function D(t, r) {
            if (Array.isArray(t))
              return t[0] && Array.isArray(t[0]) ? new P(t) : new j(t, r);
            throw new Error("the argument is not an array");
          }
          class _ {
            constructor(t) {
              var r,
                e,
                n,
                i,
                o = (t = P.checkMatrix(t)).clone(),
                s = t.rows,
                a = t.columns,
                h = new Array(a);
              for (n = 0; n < a; n++) {
                var l = 0;
                for (r = n; r < s; r++) l = u(l, o.get(r, n));
                if (0 !== l) {
                  for (o.get(n, n) < 0 && (l = -l), r = n; r < s; r++)
                    o.set(r, n, o.get(r, n) / l);
                  for (o.set(n, n, o.get(n, n) + 1), e = n + 1; e < a; e++) {
                    for (i = 0, r = n; r < s; r++)
                      i += o.get(r, n) * o.get(r, e);
                    for (i = -i / o.get(n, n), r = n; r < s; r++)
                      o.set(r, e, o.get(r, e) + i * o.get(r, n));
                  }
                }
                h[n] = -l;
              }
              (this.QR = o), (this.Rdiag = h);
            }
            solve(t) {
              t = I.checkMatrix(t);
              var r = this.QR,
                e = r.rows;
              if (t.rows !== e)
                throw new Error("Matrix row dimensions must agree");
              if (!this.isFullRank())
                throw new Error("Matrix is rank deficient");
              var n,
                i,
                o,
                s,
                a = t.columns,
                h = t.clone(),
                u = r.columns;
              for (o = 0; o < u; o++)
                for (i = 0; i < a; i++) {
                  for (s = 0, n = o; n < e; n++) s += r[n][o] * h[n][i];
                  for (s = -s / r[o][o], n = o; n < e; n++)
                    h[n][i] += s * r[n][o];
                }
              for (o = u - 1; o >= 0; o--) {
                for (i = 0; i < a; i++) h[o][i] /= this.Rdiag[o];
                for (n = 0; n < o; n++)
                  for (i = 0; i < a; i++) h[n][i] -= h[o][i] * r[n][o];
              }
              return h.subMatrix(0, u - 1, 0, a - 1);
            }
            isFullRank() {
              for (var t = this.QR.columns, r = 0; r < t; r++)
                if (0 === this.Rdiag[r]) return !1;
              return !0;
            }
            get upperTriangularMatrix() {
              var t,
                r,
                e = this.QR,
                n = e.columns,
                i = new I(n, n);
              for (t = 0; t < n; t++)
                for (r = 0; r < n; r++)
                  i[t][r] = t < r ? e[t][r] : t === r ? this.Rdiag[t] : 0;
              return i;
            }
            get orthogonalMatrix() {
              var t,
                r,
                e,
                n,
                i = this.QR,
                o = i.rows,
                s = i.columns,
                a = new I(o, s);
              for (e = s - 1; e >= 0; e--) {
                for (t = 0; t < o; t++) a[t][e] = 0;
                for (a[e][e] = 1, r = e; r < s; r++)
                  if (0 !== i[e][e]) {
                    for (n = 0, t = e; t < o; t++) n += i[t][e] * a[t][r];
                    for (n = -n / i[e][e], t = e; t < o; t++)
                      a[t][r] += n * i[t][e];
                  }
              }
              return a;
            }
          }
          function L(t, r = !1) {
            return (
              (t = P.checkMatrix(t)),
              r ? new f(t).inverse() : O(t, I.eye(t.rows))
            );
          }
          function O(t, r, e = !1) {
            return (
              (t = P.checkMatrix(t)),
              (r = P.checkMatrix(r)),
              e
                ? new f(t).solve(r)
                : t.isSquare()
                ? new h(t).solve(r)
                : new _(t).solve(r)
            );
          }
          function q(t, r) {
            for (var e = [], n = 0; n < t; n++) n !== r && e.push(n);
            return e;
          }
          function T(t, r, e, n = 1e-9, i = 1e-9) {
            if (t > i) return new Array(r.rows + 1).fill(0);
            for (var o = r.addRow(e, [0]), s = 0; s < o.rows; s++)
              Math.abs(o.get(s, 0)) < n && o.set(s, 0, 0);
            return o.to1DArray();
          }
          function U(t, r = {}) {
            const { thresholdValue: e = 1e-9, thresholdError: n = 1e-9 } = r;
            for (var i = t.rows, s = new I(i, i), a = 0; a < i; a++) {
              var h = I.columnVector(t.getRow(a)),
                u = t.subMatrixRow(q(i, a)).transposeView(),
                l = new f(u).solve(h),
                c = o(I.sub(h, u.mmul(l)).abs().to1DArray());
              s.setRow(a, T(c, l, a, e, n));
            }
            return s;
          }
          class $ {
            constructor(t, r = {}) {
              const { assumeSymmetric: e = !1 } = r;
              if (!(t = P.checkMatrix(t)).isSquare())
                throw new Error("Matrix is not a square matrix");
              var n,
                i,
                o = t.columns,
                s = l(o, o, 0),
                a = new Array(o),
                h = new Array(o),
                f = t;
              if (!!e || t.isSymmetric()) {
                for (n = 0; n < o; n++)
                  for (i = 0; i < o; i++) s[n][i] = f.get(n, i);
                !(function (t, r, e, n) {
                  var i, o, s, a, h, u, l, f;
                  for (h = 0; h < t; h++) e[h] = n[t - 1][h];
                  for (a = t - 1; a > 0; a--) {
                    for (f = 0, s = 0, u = 0; u < a; u++) f += Math.abs(e[u]);
                    if (0 === f)
                      for (r[a] = e[a - 1], h = 0; h < a; h++)
                        (e[h] = n[a - 1][h]), (n[a][h] = 0), (n[h][a] = 0);
                    else {
                      for (u = 0; u < a; u++) (e[u] /= f), (s += e[u] * e[u]);
                      for (
                        i = e[a - 1],
                          o = Math.sqrt(s),
                          i > 0 && (o = -o),
                          r[a] = f * o,
                          s -= i * o,
                          e[a - 1] = i - o,
                          h = 0;
                        h < a;
                        h++
                      )
                        r[h] = 0;
                      for (h = 0; h < a; h++) {
                        for (
                          i = e[h],
                            n[h][a] = i,
                            o = r[h] + n[h][h] * i,
                            u = h + 1;
                          u <= a - 1;
                          u++
                        )
                          (o += n[u][h] * e[u]), (r[u] += n[u][h] * i);
                        r[h] = o;
                      }
                      for (i = 0, h = 0; h < a; h++)
                        (r[h] /= s), (i += r[h] * e[h]);
                      for (l = i / (s + s), h = 0; h < a; h++) r[h] -= l * e[h];
                      for (h = 0; h < a; h++) {
                        for (i = e[h], o = r[h], u = h; u <= a - 1; u++)
                          n[u][h] -= i * r[u] + o * e[u];
                        (e[h] = n[a - 1][h]), (n[a][h] = 0);
                      }
                    }
                    e[a] = s;
                  }
                  for (a = 0; a < t - 1; a++) {
                    if (
                      ((n[t - 1][a] = n[a][a]),
                      (n[a][a] = 1),
                      0 !== (s = e[a + 1]))
                    ) {
                      for (u = 0; u <= a; u++) e[u] = n[u][a + 1] / s;
                      for (h = 0; h <= a; h++) {
                        for (o = 0, u = 0; u <= a; u++)
                          o += n[u][a + 1] * n[u][h];
                        for (u = 0; u <= a; u++) n[u][h] -= o * e[u];
                      }
                    }
                    for (u = 0; u <= a; u++) n[u][a + 1] = 0;
                  }
                  for (h = 0; h < t; h++)
                    (e[h] = n[t - 1][h]), (n[t - 1][h] = 0);
                  (n[t - 1][t - 1] = 1), (r[0] = 0);
                })(o, h, a, s),
                  (function (t, r, e, n) {
                    var i, o, s, a, h, l, f, c, m, g, v, p, w, d, y, b;
                    for (s = 1; s < t; s++) r[s - 1] = r[s];
                    r[t - 1] = 0;
                    var M = 0,
                      x = 0,
                      S = Number.EPSILON;
                    for (l = 0; l < t; l++) {
                      for (
                        x = Math.max(x, Math.abs(e[l]) + Math.abs(r[l])), f = l;
                        f < t && !(Math.abs(r[f]) <= S * x);

                      )
                        f++;
                      if (f > l) {
                        0;
                        do {
                          for (
                            1,
                              i = e[l],
                              c = (e[l + 1] - i) / (2 * r[l]),
                              m = u(c, 1),
                              c < 0 && (m = -m),
                              e[l] = r[l] / (c + m),
                              e[l + 1] = r[l] * (c + m),
                              g = e[l + 1],
                              o = i - e[l],
                              s = l + 2;
                            s < t;
                            s++
                          )
                            e[s] -= o;
                          for (
                            M += o,
                              c = e[f],
                              p = v = 1,
                              w = v,
                              d = r[l + 1],
                              y = 0,
                              b = 0,
                              s = f - 1;
                            s >= l;
                            s--
                          )
                            for (
                              w = p,
                                p = v,
                                b = y,
                                i = v * r[s],
                                o = v * c,
                                m = u(c, r[s]),
                                r[s + 1] = y * m,
                                y = r[s] / m,
                                c = (v = c / m) * e[s] - y * i,
                                e[s + 1] = o + y * (v * i + y * e[s]),
                                h = 0;
                              h < t;
                              h++
                            )
                              (o = n[h][s + 1]),
                                (n[h][s + 1] = y * n[h][s] + v * o),
                                (n[h][s] = v * n[h][s] - y * o);
                          (c = (-y * b * w * d * r[l]) / g),
                            (r[l] = y * c),
                            (e[l] = v * c);
                        } while (Math.abs(r[l]) > S * x);
                      }
                      (e[l] = e[l] + M), (r[l] = 0);
                    }
                    for (s = 0; s < t - 1; s++) {
                      for (h = s, c = e[s], a = s + 1; a < t; a++)
                        e[a] < c && ((h = a), (c = e[a]));
                      if (h !== s)
                        for (e[h] = e[s], e[s] = c, a = 0; a < t; a++)
                          (c = n[a][s]), (n[a][s] = n[a][h]), (n[a][h] = c);
                    }
                  })(o, h, a, s);
              } else {
                var c = l(o, o, 0),
                  m = new Array(o);
                for (i = 0; i < o; i++)
                  for (n = 0; n < o; n++) c[n][i] = f.get(n, i);
                !(function (t, r, e, n) {
                  var i,
                    o,
                    s,
                    a,
                    h,
                    u,
                    l,
                    f = t - 1;
                  for (u = 1; u <= f - 1; u++) {
                    for (l = 0, a = u; a <= f; a++) l += Math.abs(r[a][u - 1]);
                    if (0 !== l) {
                      for (s = 0, a = f; a >= u; a--)
                        (e[a] = r[a][u - 1] / l), (s += e[a] * e[a]);
                      for (
                        o = Math.sqrt(s),
                          e[u] > 0 && (o = -o),
                          s -= e[u] * o,
                          e[u] = e[u] - o,
                          h = u;
                        h < t;
                        h++
                      ) {
                        for (i = 0, a = f; a >= u; a--) i += e[a] * r[a][h];
                        for (i /= s, a = u; a <= f; a++) r[a][h] -= i * e[a];
                      }
                      for (a = 0; a <= f; a++) {
                        for (i = 0, h = f; h >= u; h--) i += e[h] * r[a][h];
                        for (i /= s, h = u; h <= f; h++) r[a][h] -= i * e[h];
                      }
                      (e[u] = l * e[u]), (r[u][u - 1] = l * o);
                    }
                  }
                  for (a = 0; a < t; a++)
                    for (h = 0; h < t; h++) n[a][h] = a === h ? 1 : 0;
                  for (u = f - 1; u >= 1; u--)
                    if (0 !== r[u][u - 1]) {
                      for (a = u + 1; a <= f; a++) e[a] = r[a][u - 1];
                      for (h = u; h <= f; h++) {
                        for (o = 0, a = u; a <= f; a++) o += e[a] * n[a][h];
                        for (o = o / e[u] / r[u][u - 1], a = u; a <= f; a++)
                          n[a][h] += o * e[a];
                      }
                    }
                })(o, c, m, s),
                  (function (t, r, e, n, i) {
                    var o,
                      s,
                      a,
                      h,
                      u,
                      l,
                      f,
                      c,
                      m,
                      g,
                      v,
                      p,
                      w,
                      d,
                      y,
                      b = t - 1,
                      M = t - 1,
                      x = Number.EPSILON,
                      S = 0,
                      E = 0,
                      R = 0,
                      k = 0,
                      A = 0,
                      N = 0,
                      V = 0,
                      z = 0;
                    for (o = 0; o < t; o++)
                      for (
                        (o < 0 || o > M) && ((e[o] = i[o][o]), (r[o] = 0)),
                          s = Math.max(o - 1, 0);
                        s < t;
                        s++
                      )
                        E += Math.abs(i[o][s]);
                    for (; b >= 0; ) {
                      for (
                        h = b;
                        h > 0 &&
                        (0 ===
                          (N = Math.abs(i[h - 1][h - 1]) + Math.abs(i[h][h])) &&
                          (N = E),
                        !(Math.abs(i[h][h - 1]) < x * N));

                      )
                        h--;
                      if (h === b)
                        (i[b][b] = i[b][b] + S),
                          (e[b] = i[b][b]),
                          (r[b] = 0),
                          b--,
                          (z = 0);
                      else if (h === b - 1) {
                        if (
                          ((f = i[b][b - 1] * i[b - 1][b]),
                          (R = (i[b - 1][b - 1] - i[b][b]) / 2),
                          (k = R * R + f),
                          (V = Math.sqrt(Math.abs(k))),
                          (i[b][b] = i[b][b] + S),
                          (i[b - 1][b - 1] = i[b - 1][b - 1] + S),
                          (c = i[b][b]),
                          k >= 0)
                        ) {
                          for (
                            V = R >= 0 ? R + V : R - V,
                              e[b - 1] = c + V,
                              e[b] = e[b - 1],
                              0 !== V && (e[b] = c - f / V),
                              r[b - 1] = 0,
                              r[b] = 0,
                              c = i[b][b - 1],
                              N = Math.abs(c) + Math.abs(V),
                              R = c / N,
                              k = V / N,
                              A = Math.sqrt(R * R + k * k),
                              R /= A,
                              k /= A,
                              s = b - 1;
                            s < t;
                            s++
                          )
                            (V = i[b - 1][s]),
                              (i[b - 1][s] = k * V + R * i[b][s]),
                              (i[b][s] = k * i[b][s] - R * V);
                          for (o = 0; o <= b; o++)
                            (V = i[o][b - 1]),
                              (i[o][b - 1] = k * V + R * i[o][b]),
                              (i[o][b] = k * i[o][b] - R * V);
                          for (o = 0; o <= M; o++)
                            (V = n[o][b - 1]),
                              (n[o][b - 1] = k * V + R * n[o][b]),
                              (n[o][b] = k * n[o][b] - R * V);
                        } else
                          (e[b - 1] = c + R),
                            (e[b] = c + R),
                            (r[b - 1] = V),
                            (r[b] = -V);
                        (b -= 2), (z = 0);
                      } else {
                        if (
                          ((c = i[b][b]),
                          (m = 0),
                          (f = 0),
                          h < b &&
                            ((m = i[b - 1][b - 1]),
                            (f = i[b][b - 1] * i[b - 1][b])),
                          10 === z)
                        ) {
                          for (S += c, o = 0; o <= b; o++) i[o][o] -= c;
                          (N =
                            Math.abs(i[b][b - 1]) + Math.abs(i[b - 1][b - 2])),
                            (c = m = 0.75 * N),
                            (f = -0.4375 * N * N);
                        }
                        if (30 === z && (N = (N = (m - c) / 2) * N + f) > 0) {
                          for (
                            N = Math.sqrt(N),
                              m < c && (N = -N),
                              N = c - f / ((m - c) / 2 + N),
                              o = 0;
                            o <= b;
                            o++
                          )
                            i[o][o] -= N;
                          (S += N), (c = m = f = 0.964);
                        }
                        for (
                          z += 1, u = b - 2;
                          u >= h &&
                          ((V = i[u][u]),
                          (R =
                            ((A = c - V) * (N = m - V) - f) / i[u + 1][u] +
                            i[u][u + 1]),
                          (k = i[u + 1][u + 1] - V - A - N),
                          (A = i[u + 2][u + 1]),
                          (N = Math.abs(R) + Math.abs(k) + Math.abs(A)),
                          (R /= N),
                          (k /= N),
                          (A /= N),
                          u !== h) &&
                          !(
                            Math.abs(i[u][u - 1]) *
                              (Math.abs(k) + Math.abs(A)) <
                            x *
                              (Math.abs(R) *
                                (Math.abs(i[u - 1][u - 1]) +
                                  Math.abs(V) +
                                  Math.abs(i[u + 1][u + 1])))
                          );

                        )
                          u--;
                        for (o = u + 2; o <= b; o++)
                          (i[o][o - 2] = 0), o > u + 2 && (i[o][o - 3] = 0);
                        for (
                          a = u;
                          a <= b - 1 &&
                          ((d = a !== b - 1),
                          a !== u &&
                            ((R = i[a][a - 1]),
                            (k = i[a + 1][a - 1]),
                            (A = d ? i[a + 2][a - 1] : 0),
                            0 !==
                              (c = Math.abs(R) + Math.abs(k) + Math.abs(A)) &&
                              ((R /= c), (k /= c), (A /= c))),
                          0 !== c);
                          a++
                        )
                          if (
                            ((N = Math.sqrt(R * R + k * k + A * A)),
                            R < 0 && (N = -N),
                            0 !== N)
                          ) {
                            for (
                              a !== u
                                ? (i[a][a - 1] = -N * c)
                                : h !== u && (i[a][a - 1] = -i[a][a - 1]),
                                c = (R += N) / N,
                                m = k / N,
                                V = A / N,
                                k /= R,
                                A /= R,
                                s = a;
                              s < t;
                              s++
                            )
                              (R = i[a][s] + k * i[a + 1][s]),
                                d &&
                                  ((R += A * i[a + 2][s]),
                                  (i[a + 2][s] = i[a + 2][s] - R * V)),
                                (i[a][s] = i[a][s] - R * c),
                                (i[a + 1][s] = i[a + 1][s] - R * m);
                            for (o = 0; o <= Math.min(b, a + 3); o++)
                              (R = c * i[o][a] + m * i[o][a + 1]),
                                d &&
                                  ((R += V * i[o][a + 2]),
                                  (i[o][a + 2] = i[o][a + 2] - R * A)),
                                (i[o][a] = i[o][a] - R),
                                (i[o][a + 1] = i[o][a + 1] - R * k);
                            for (o = 0; o <= M; o++)
                              (R = c * n[o][a] + m * n[o][a + 1]),
                                d &&
                                  ((R += V * n[o][a + 2]),
                                  (n[o][a + 2] = n[o][a + 2] - R * A)),
                                (n[o][a] = n[o][a] - R),
                                (n[o][a + 1] = n[o][a + 1] - R * k);
                          }
                      }
                    }
                    if (0 === E) return;
                    for (b = t - 1; b >= 0; b--)
                      if (((R = e[b]), 0 === (k = r[b])))
                        for (h = b, i[b][b] = 1, o = b - 1; o >= 0; o--) {
                          for (f = i[o][o] - R, A = 0, s = h; s <= b; s++)
                            A += i[o][s] * i[s][b];
                          if (r[o] < 0) (V = f), (N = A);
                          else if (
                            ((h = o),
                            0 === r[o]
                              ? (i[o][b] = 0 !== f ? -A / f : -A / (x * E))
                              : ((c = i[o][o + 1]),
                                (m = i[o + 1][o]),
                                (k = (e[o] - R) * (e[o] - R) + r[o] * r[o]),
                                (l = (c * N - V * A) / k),
                                (i[o][b] = l),
                                (i[o + 1][b] =
                                  Math.abs(c) > Math.abs(V)
                                    ? (-A - f * l) / c
                                    : (-N - m * l) / V)),
                            (l = Math.abs(i[o][b])),
                            x * l * l > 1)
                          )
                            for (s = o; s <= b; s++) i[s][b] = i[s][b] / l;
                        }
                      else if (k < 0)
                        for (
                          h = b - 1,
                            Math.abs(i[b][b - 1]) > Math.abs(i[b - 1][b])
                              ? ((i[b - 1][b - 1] = k / i[b][b - 1]),
                                (i[b - 1][b] = -(i[b][b] - R) / i[b][b - 1]))
                              : ((y = F(
                                  0,
                                  -i[b - 1][b],
                                  i[b - 1][b - 1] - R,
                                  k
                                )),
                                (i[b - 1][b - 1] = y[0]),
                                (i[b - 1][b] = y[1])),
                            i[b][b - 1] = 0,
                            i[b][b] = 1,
                            o = b - 2;
                          o >= 0;
                          o--
                        ) {
                          for (g = 0, v = 0, s = h; s <= b; s++)
                            (g += i[o][s] * i[s][b - 1]),
                              (v += i[o][s] * i[s][b]);
                          if (((f = i[o][o] - R), r[o] < 0))
                            (V = f), (A = g), (N = v);
                          else if (
                            ((h = o),
                            0 === r[o]
                              ? ((y = F(-g, -v, f, k)),
                                (i[o][b - 1] = y[0]),
                                (i[o][b] = y[1]))
                              : ((c = i[o][o + 1]),
                                (m = i[o + 1][o]),
                                (p =
                                  (e[o] - R) * (e[o] - R) +
                                  r[o] * r[o] -
                                  k * k),
                                (w = 2 * (e[o] - R) * k),
                                0 === p &&
                                  0 === w &&
                                  (p =
                                    x *
                                    E *
                                    (Math.abs(f) +
                                      Math.abs(k) +
                                      Math.abs(c) +
                                      Math.abs(m) +
                                      Math.abs(V))),
                                (y = F(
                                  c * A - V * g + k * v,
                                  c * N - V * v - k * g,
                                  p,
                                  w
                                )),
                                (i[o][b - 1] = y[0]),
                                (i[o][b] = y[1]),
                                Math.abs(c) > Math.abs(V) + Math.abs(k)
                                  ? ((i[o + 1][b - 1] =
                                      (-g - f * i[o][b - 1] + k * i[o][b]) / c),
                                    (i[o + 1][b] =
                                      (-v - f * i[o][b] - k * i[o][b - 1]) / c))
                                  : ((y = F(
                                      -A - m * i[o][b - 1],
                                      -N - m * i[o][b],
                                      V,
                                      k
                                    )),
                                    (i[o + 1][b - 1] = y[0]),
                                    (i[o + 1][b] = y[1]))),
                            (l = Math.max(
                              Math.abs(i[o][b - 1]),
                              Math.abs(i[o][b])
                            )),
                            x * l * l > 1)
                          )
                            for (s = o; s <= b; s++)
                              (i[s][b - 1] = i[s][b - 1] / l),
                                (i[s][b] = i[s][b] / l);
                        }
                    for (o = 0; o < t; o++)
                      if (o < 0 || o > M)
                        for (s = o; s < t; s++) n[o][s] = i[o][s];
                    for (s = t - 1; s >= 0; s--)
                      for (o = 0; o <= M; o++) {
                        for (V = 0, a = 0; a <= Math.min(s, M); a++)
                          V += n[o][a] * i[a][s];
                        n[o][s] = V;
                      }
                  })(o, h, a, s, c);
              }
              (this.n = o), (this.e = h), (this.d = a), (this.V = s);
            }
            get realEigenvalues() {
              return this.d;
            }
            get imaginaryEigenvalues() {
              return this.e;
            }
            get eigenvectorMatrix() {
              return I.isMatrix(this.V) || (this.V = new I(this.V)), this.V;
            }
            get diagonalMatrix() {
              var t,
                r,
                e = this.n,
                n = this.e,
                i = this.d,
                o = new I(e, e);
              for (t = 0; t < e; t++) {
                for (r = 0; r < e; r++) o[t][r] = 0;
                (o[t][t] = i[t]),
                  n[t] > 0
                    ? (o[t][t + 1] = n[t])
                    : n[t] < 0 && (o[t][t - 1] = n[t]);
              }
              return o;
            }
          }
          function F(t, r, e, n) {
            var i, o;
            return Math.abs(e) > Math.abs(n)
              ? [(t + (i = n / e) * r) / (o = e + i * n), (r - i * t) / o]
              : [((i = e / n) * t + r) / (o = n + i * e), (i * r - t) / o];
          }
          class W {
            constructor(t) {
              if (!(t = P.checkMatrix(t)).isSymmetric())
                throw new Error("Matrix is not symmetric");
              var r,
                e,
                n,
                i = t,
                o = i.rows,
                s = new I(o, o),
                a = !0;
              for (e = 0; e < o; e++) {
                var h = s[e],
                  u = 0;
                for (n = 0; n < e; n++) {
                  var l = s[n],
                    f = 0;
                  for (r = 0; r < n; r++) f += l[r] * h[r];
                  (h[n] = f = (i.get(e, n) - f) / s[n][n]), (u += f * f);
                }
                for (
                  a &= (u = i.get(e, e) - u) > 0,
                    s[e][e] = Math.sqrt(Math.max(u, 0)),
                    n = e + 1;
                  n < o;
                  n++
                )
                  s[e][n] = 0;
              }
              if (!a) throw new Error("Matrix is not positive definite");
              this.L = s;
            }
            solve(t) {
              t = P.checkMatrix(t);
              var r = this.L,
                e = r.rows;
              if (t.rows !== e)
                throw new Error("Matrix dimensions do not match");
              var n,
                i,
                o,
                s = t.columns,
                a = t.clone();
              for (o = 0; o < e; o++)
                for (i = 0; i < s; i++) {
                  for (n = 0; n < o; n++) a[o][i] -= a[n][i] * r[o][n];
                  a[o][i] /= r[o][o];
                }
              for (o = e - 1; o >= 0; o--)
                for (i = 0; i < s; i++) {
                  for (n = o + 1; n < e; n++) a[o][i] -= a[n][i] * r[n][o];
                  a[o][i] /= r[o][o];
                }
              return a;
            }
            get lowerTriangularMatrix() {
              return this.L;
            }
          }
          e.d(r, "default", function () {
            return I;
          }),
            e.d(r, "Matrix", function () {
              return I;
            }),
            e.d(r, "abstractMatrix", function () {
              return C;
            }),
            e.d(r, "wrap", function () {
              return D;
            }),
            e.d(r, "WrapperMatrix2D", function () {
              return P;
            }),
            e.d(r, "WrapperMatrix1D", function () {
              return j;
            }),
            e.d(r, "solve", function () {
              return O;
            }),
            e.d(r, "inverse", function () {
              return L;
            }),
            e.d(r, "linearDependencies", function () {
              return U;
            }),
            e.d(r, "SingularValueDecomposition", function () {
              return f;
            }),
            e.d(r, "SVD", function () {
              return f;
            }),
            e.d(r, "EigenvalueDecomposition", function () {
              return $;
            }),
            e.d(r, "EVD", function () {
              return $;
            }),
            e.d(r, "CholeskyDecomposition", function () {
              return W;
            }),
            e.d(r, "CHO", function () {
              return W;
            }),
            e.d(r, "LuDecomposition", function () {
              return h;
            }),
            e.d(r, "LU", function () {
              return h;
            }),
            e.d(r, "QrDecomposition", function () {
              return _;
            }),
            e.d(r, "QR", function () {
              return _;
            });
        },
      ]);
    </script>
  </body>
</html>
